<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
  <title>3D Glide-Over-Line Captioner (Resolve Transcript Sync)</title>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; background:#000; overflow:hidden; }
    canvas { width:100%; height:100%; display:block; }

    #ui {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 9999;
      background: rgba(0,0,0,0.78);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 12px;
      border-radius: 12px;
      color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: 12px;
      width: 290px;
      max-height: calc(100vh - 20px);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      user-select: none;
      box-shadow: 0 10px 40px rgba(0,0,0,0.45);
      backdrop-filter: blur(6px);
      transition: transform 160ms ease, opacity 160ms ease;
    }

    /* collapsed state: tuck it mostly offscreen but keep a tab */
    #ui.collapsed {
      transform: translateX(calc(100% - 300px));
      opacity: 0.92;
    }

    /* header with collapse toggle */
    #uiHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 6px;
    }

    #uiTitle {
      font-weight: 900;
      font-size: 13px;
      line-height: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #uiToggle {
      width: 38px;
      height: 28px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.08);
      color: #fff;
      cursor: pointer;
      font-weight: 900;
      display: grid;
      place-items: center;
      user-select: none;
    }

    /* when collapsed, hide all content except header (and make header look like a tab) */
    #ui.collapsed #uiBody { display: none; }
    #ui.collapsed {
      padding: 10px 8px;
      width: 290px; /* keep same width for consistent slide */
    }
    #ui.collapsed #uiHeader {
      margin-bottom: 0;
    }
    #ui.collapsed #uiTitle {
      opacity: 0.85;
      font-size: 12px;
    }

    #ui button {
      width: 100%;
      padding: 10px 10px;
      margin: 6px 0;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 800;
      letter-spacing: 0.2px;
    }

    #btnLoad   { background: #00ccff; color:#001018; }
    #btnCreate { background: #4caf50; color:#fff; }
    #btnReplay { background: #303030; color:#fff; }
    #btnRecord { background: #ff3b30; color:#fff; }
    #btnStop   { background: #ff9500; color:#111; display:none; }

    #ui label { display:block; margin-top:10px; opacity: 0.95; }
    #ui input[type="range"] { width: 100%; margin-top: 6px; }
    #ui input[type="checkbox"] { transform: translateY(1px); }
    #ui .row { display:flex; gap:8px; }
    #ui .row button { width: 50%; }

    #status {
      margin-top: 8px;
      line-height: 1.35;
      opacity: 0.92;
      white-space: pre-wrap;
    }
    #hint { opacity:0.7; margin-top:6px; }
    #mini { margin-top: 8px; opacity: 0.75; font-size: 11px; line-height: 1.25; }
    #mini code { opacity: 0.9; }

    #uiBody {
      flex: 1;
      overflow-y: auto;
      padding-right: 4px;
    }

    #uiBody::-webkit-scrollbar { width: 8px; }
    #uiBody::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.18); border-radius: 999px; }
    #uiBody::-webkit-scrollbar-track { background: transparent; }

    /* Config panel */
    details.cfgbox {
      margin-top: 10px;
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      overflow: hidden;
      background: rgba(255,255,255,0.03);
    }
    details.cfgbox > summary {
      list-style: none;
      cursor: pointer;
      padding: 10px 10px;
      font-weight: 850;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      background: rgba(0,0,0,0.18);
    }
    details.cfgbox > summary::-webkit-details-marker { display:none; }
    .pill {
      font-size: 11px;
      opacity: 0.75;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.28);
    }
    .cfggrid {
      padding: 10px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }
    .cfgrow {
      display: grid;
      grid-template-columns: 1fr 110px;
      gap: 8px;
      align-items: center;
    }
    .cfgrow label {
      margin: 0;
      opacity: 0.9;
      font-weight: 650;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .cfgrow small {
      opacity: 0.65;
      font-weight: 500;
      line-height: 1.1;
    }
    .cfgrow input[type="number"],
    .cfgrow input[type="text"] {
      width: 100%;
      padding: 8px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.30);
      color: #fff;
      outline: none;
    }
    .cfgrow input::placeholder { color: rgba(255,255,255,0.35); }
    .cfgactions {
      padding: 10px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      border-top: 1px solid rgba(255,255,255,0.08);
      background: rgba(0,0,0,0.12);
    }
    .cfgactions button {
      margin: 0;
      padding: 10px;
      border-radius: 10px;
      background: rgba(255,255,255,0.10);
      color: #fff;
    }
    .cfgactions button.primary {
      background: rgba(0, 204, 255, 0.85);
      color: #06141a;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div id="ui" class="collapsed">
  <div id="uiHeader">
    <div id="uiTitle">Resolve Transcript Sync</div>
    <button id="uiToggle" title="Collapse/Expand">◀</button>
  </div>

  <div id="uiBody">
    <button id="btnLoad">Load from Resolve</button>
    <button id="btnReplay">Replay</button>
    <button id="btnCreate">Create Captions in Resolve</button>

    <div class="row">
      <button id="btnRecord">Record (WebM)</button>
      <button id="btnStop">Stop</button>
    </div>

    <label>
      Words per line: <span id="wplVal">8</span>
      <input id="wpl" type="range" min="3" max="14" step="1" value="8" />
    </label>

    <label>
      End overhang: <span id="ohVal">0.65</span> (× last-word width)
      <input id="oh" type="range" min="0" max="1" step="0.05" value="0.65" />
    </label>

    <label style="display:flex; align-items:center; gap:10px;">
      <input id="keepPrev" type="checkbox" />
      keepPreviousLinesVisible
    </label>

    <details class="cfgbox" id="cfgDetails">
      <summary>
        <span>Advanced cfg</span>
        <span class="pill" id="cfgPill">collapsed</span>
      </summary>

      <div class="cfggrid" id="cfgGrid"></div>

      <div class="cfgactions">
        <button id="cfgReset">Reset</button>
        <button class="primary" id="cfgApply">Apply</button>
      </div>
    </details>

    <div id="status">Idle.</div>
    <div id="hint">Tip: In Resolve, select a clip → right-click → Transcribe Audio.</div>
    <div id="mini">
      Export note: recording uses <code>canvas.captureStream</code> + <code>MediaRecorder</code>.
      Some iOS browsers may block WebM recording.
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>

<script>
  // -------------------------
  // CONFIG (defaults)
  // -------------------------
  const DEFAULT_CFG = Object.freeze({
    linesUrl: './demo-lines.txt',

    textSize:  0.10,
    textDepth: 0.001,

    color:     0xffffff,
    cameraDistance: 3.5,

    wordsPerSecond:  2.5,
    curveLookAheadU: 0.055,
    followLambda:    19,
    lookAtLambda:    12,
    revealWordLead:  1.15,

    spaceMultiplier: 1.55,

    revealMs:         220,
    revealPopScale:   1.22,
    revealRise:       0.05,
    revealZ:          0.06,
    revealOvershoot:  0.08,

    endOverhangFactor: 0.65,
    endOverhangPx:     0.16,
    trackLeadPx:       0.08,
    endOverhangBlendU: 0.10,
    endEaseOutU:       0.14,

    keepPreviousLinesVisible: false,
    lineHoldMsAfterComplete:  620,

    stackLines: true,
    stackLineGap: 0.22,
    stackAnchor: 'bottom',
    stackMaxLines: 6
  });

  const cfg = structuredClone(DEFAULT_CFG);

  // -------------------------
  // THREE SETUP
  // -------------------------
  const canvas   = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.05, 200);
  scene.add(camera);

  const ambient = new THREE.AmbientLight(0xffffff, 0.35);
  const rimLight = new THREE.DirectionalLight(0x6ec8ff, 0.55);
  rimLight.position.set(0.7, 1.1, 1.8);
  const fillLight = new THREE.PointLight(0xffffff, 0.28);
  fillLight.position.set(-1.4, -0.6, 1.2);
  scene.add(ambient);
  camera.add(rimLight);
  camera.add(fillLight);

  function createBaseMaterial() {
    return new THREE.MeshPhongMaterial({
      color: cfg.color,
      emissive: new THREE.Color(cfg.color).multiplyScalar(0.18),
      specular: new THREE.Color(0xffffff),
      shininess: 85,
      transparent: true,
      opacity: 1
    });
  }

  let baseMat = createBaseMaterial();

  let lineObjs = [];
  let transcriptionData = null;
  let fontRef = null;

  let stackedLineCount = 0;

  // -------------------------
  // UI refs
  // -------------------------
  const ui = document.getElementById('ui');
  const uiToggle = document.getElementById('uiToggle');

  const statusEl = document.getElementById('status');
  const wplEl = document.getElementById('wpl');
  const wplValEl = document.getElementById('wplVal');
  const ohEl = document.getElementById('oh');
  const ohValEl = document.getElementById('ohVal');
  const keepPrevEl = document.getElementById('keepPrev');

  const btnLoad = document.getElementById('btnLoad');
  const btnReplay = document.getElementById('btnReplay');
  const btnCreate = document.getElementById('btnCreate');
  const btnRecord = document.getElementById('btnRecord');
  const btnStop = document.getElementById('btnStop');

  const cfgDetails = document.getElementById('cfgDetails');
  const cfgPill = document.getElementById('cfgPill');
  const cfgGrid = document.getElementById('cfgGrid');
  const cfgResetBtn = document.getElementById('cfgReset');
  const cfgApplyBtn = document.getElementById('cfgApply');

  function setStatus(msg) { statusEl.textContent = msg; }

  // Collapsible main UI panel
  function setUiCollapsed(isCollapsed) {
    ui.classList.toggle('collapsed', !!isCollapsed);
    uiToggle.textContent = isCollapsed ? '◀' : '▶';
    uiToggle.title = isCollapsed ? 'Expand' : 'Collapse';
    try { localStorage.setItem('captioner_ui_collapsed', isCollapsed ? '1' : '0'); } catch (_) {}
  }

  uiToggle.addEventListener('click', () => {
    setUiCollapsed(!ui.classList.contains('collapsed'));
  });

  // restore collapsed state (default collapsed)
  try {
    const v = localStorage.getItem('captioner_ui_collapsed');
    setUiCollapsed(v === null ? true : (v === '1'));
  } catch (_) {
    setUiCollapsed(true);
  }

  wplEl.addEventListener('input', () => { wplValEl.textContent = String(wplEl.value); });

  ohEl.value = String(cfg.endOverhangFactor);
  ohValEl.textContent = Number(cfg.endOverhangFactor).toFixed(2);

  ohEl.addEventListener('input', () => {
    const v = Number(ohEl.value);
    cfg.endOverhangFactor = v;
    ohValEl.textContent = v.toFixed(2);
  });

  keepPrevEl.addEventListener('change', () => {
    cfg.keepPreviousLinesVisible = !!keepPrevEl.checked;
    setStatus('Applied keepPreviousLinesVisible: ' + cfg.keepPreviousLinesVisible + '\n(Rebuild on Replay)');
  });

  cfgDetails.addEventListener('toggle', () => {
    cfgPill.textContent = cfgDetails.open ? 'expanded' : 'collapsed';
  });

  // -------------------------
  // Helpers
  // -------------------------
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function smooth01(t){ t = clamp01(t); return t * t * (3 - 2 * t); }
  function easeOutCubic(t){ t = clamp01(t); return 1 - Math.pow(1 - t, 3); }
  function easeOutBack(t, overshoot = 0.30){
    t = clamp01(t);
    const c1 = 1.70158 + overshoot * 2.0;
    const c3 = c1 + 1;
    return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
  }
  function damp(current, target, lambda, dt) {
    return current + (target - current) * (1 - Math.exp(-lambda * dt));
  }
  function render() { renderer.render(scene, camera); }

  async function loadLines(url) {
    const res = await fetch(url, { cache: 'no-store' });
    if(!res.ok) throw new Error(`Failed to load lines: ${res.status} ${res.statusText}`);
    const txt = await res.text();
    return txt.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
  }

  async function loadTranscriptionFromResolve() {
    try {
      const res = await fetch('/api/get-transcription', { cache: 'no-store' });
      const data = await res.json();
      if (data && data.error) return { error: data.error, instructions: data.instructions };
      return data;
    } catch (e) {
      return { error: String(e) };
    }
  }

  function getSpaceAdvance(font) {
    const glyph = font?.data?.glyphs?.[' '] ?? null;
    const ha = (glyph && typeof glyph.ha === 'number') ? glyph.ha : 20;
    const scale = cfg.textSize / (font.data?.resolution || 1000);
    return ha * scale;
  }

  function buildLine(font, lineText) {
    const words = lineText.split(/\s+/);
    const group = new THREE.Group();
    const spaceW = getSpaceAdvance(font) * cfg.spaceMultiplier;

    const wordData = words.map(w => {
      const geom = new THREE.TextGeometry(w, {
        font,
        size: cfg.textSize,
        height: cfg.textDepth,
        curveSegments: 2
      });
      geom.computeBoundingBox();
      const bb = geom.boundingBox;

      const width = bb.max.x - bb.min.x;
      geom.translate(-bb.min.x, 0, 0);
      return { geom, width };
    });

    const totalW =
      wordData.reduce((s,d)=>s+d.width,0) +
      (words.length - 1) * spaceW;

    let cursorX = -totalW / 2;

    const meshes  = [];
    const centers = [];
    const widths  = [];

    for (let i = 0; i < wordData.length; i++) {
      const d = wordData[i];

      const mat = baseMat.clone();
      mat.opacity = 0;

      const mesh = new THREE.Mesh(d.geom, mat);
      mesh.position.set(cursorX, 0, 0);
      mesh.visible = false;

      mesh.userData.revealStart = null;
      mesh.userData.revealed = false;
      mesh.userData.basePos = mesh.position.clone();

      group.add(mesh);
      meshes.push(mesh);

      centers.push(new THREE.Vector3(cursorX + d.width / 2, 0, 0));
      widths.push(d.width);

      cursorX += d.width + spaceW;
    }

    return { group, meshes, centers, widths };
  }

  function transcriptionToTimedLines(transcription, wordsPerLine = 8) {
    const words = Array.isArray(transcription?.words) ? transcription.words : [];
    const lines = [];
    for (let i = 0; i < words.length; i += wordsPerLine) {
      const chunk = words.slice(i, i + wordsPerLine);
      if (!chunk.length) continue;
      const text = chunk.map(w => w.text).join(' ');
      const startTime = Number(chunk[0].startTime ?? 0);
      const endTime = Number(chunk[chunk.length - 1].endTime ?? startTime);
      lines.push({ text, startTime, endTime, words: chunk });
    }
    return lines;
  }

  // -------------------------
  // Reveal animation
  // -------------------------
  function startReveal(mesh, now) {
    if (mesh.userData.revealed) return;

    mesh.userData.revealed = true;
    mesh.visible = true;
    mesh.userData.revealStart = now;

    mesh.material.opacity = 0;
    mesh.scale.setScalar(cfg.revealPopScale);
    mesh.position.set(
      mesh.userData.basePos.x,
      mesh.userData.basePos.y + cfg.revealRise,
      mesh.userData.basePos.z + cfg.revealZ
    );
  }

  function tickReveal(mesh, now) {
    if (!mesh.visible) return;
    const t0 = mesh.userData.revealStart;
    if (t0 === null) return;

    const t = clamp01((now - t0) / cfg.revealMs);
    const a = easeOutCubic(t);
    mesh.material.opacity = a;

    const pop = easeOutBack(t, cfg.revealOvershoot);
    const s = 1 + (cfg.revealPopScale - 1) * (1 - t);
    const settled = 1 + (s - 1) * (1 / pop);
    mesh.scale.setScalar(settled);

    const rise = (1 - a) * cfg.revealRise;
    const zPush = (1 - a) * cfg.revealZ;

    mesh.position.set(
      mesh.userData.basePos.x,
      mesh.userData.basePos.y + rise,
      mesh.userData.basePos.z + zPush
    );

    if (t >= 1) {
      mesh.userData.revealStart = null;
      mesh.material.opacity = 1;
      mesh.scale.setScalar(1);
      mesh.position.copy(mesh.userData.basePos);
    }
  }

  // -------------------------
  // Camera target shaping
  // -------------------------
  function computeCenterBounds(centers) {
    let minX = Infinity;
    let maxX = -Infinity;
    for (const c of centers) {
      if (!c) continue;
      if (c.x < minX) minX = c.x;
      if (c.x > maxX) maxX = c.x;
    }
    return { minX, maxX };
  }

  function endBias(u, maxBias) {
    const t = clamp01((u - 0.70) / 0.30);
    return easeOutCubic(t) * maxBias;
  }

  function shapeTargetWithBounds(target, u, centers, widths, bounds) {
    if (!centers?.length) return target;
    const { minX, maxX } = bounds ?? computeCenterBounds(centers);
    if (!isFinite(minX) || !isFinite(maxX)) return target;

    const lastW = widths?.[widths.length - 1] ?? 0;
    const bias = endBias(u, cfg.endOverhangPx + (lastW * cfg.endOverhangFactor));

    const out = target.clone();
    const lead = Math.max(0, cfg.trackLeadPx);
    out.x = Math.min(maxX + bias, Math.max(minX - lead, target.x + bias));
    return out;
  }

  function easeOutEndU(u) {
    const e = clamp01(cfg.endEaseOutU);
    if (e <= 0.0001) return u;
    const start = 1 - e;
    if (u <= start) return u;
    const t = clamp01((u - start) / e);
    const eased = easeOutCubic(t);
    return start + eased * e;
  }

  function centersWithGroupY(centers, groupY) {
    return centers.map(v => new THREE.Vector3(v.x, v.y + groupY, v.z));
  }

  // -------------------------
  // Animation: timed
  // -------------------------
  function animateLineGlideWithTiming(lineObj, onComplete) {
    const { meshes, centers, widths, words, startTime, endTime, group } = lineObj;
    const n = centers.length;

    for (const m of meshes) {
      m.visible = false;
      m.material.opacity = 0;
      m.userData.revealStart = null;
      m.userData.revealed = false;
      m.scale.setScalar(1);
      m.position.copy(m.userData.basePos);
    }

    if (n === 0) { onComplete?.(); return; }

    const c2 = centersWithGroupY(centers, group.position.y);
    const curve = new THREE.CatmullRomCurve3(c2, false, 'catmullrom', 0.5);

    const bounds = computeCenterBounds(c2);

    const ARC_SAMPLES = Math.max(320, n * 120);
    const lengths = curve.getLengths(ARC_SAMPLES);
    const totalLen = lengths[lengths.length - 1];

    const durationSec = Math.max(0.05, (endTime - startTime));
    const totalMs = durationSec * 1000;
    const start = performance.now();

    let camX = camera.position.x;
    let camY = camera.position.y;
    let lookAtX = camera.position.x;
    let lookAtY = camera.position.y;

    const followLambda = cfg.followLambda;
    const lookAheadU   = cfg.curveLookAheadU;
    let lastNow = performance.now();

    function frame(now) {
      const dt = Math.max(0.001, (now - lastNow) / 1000);
      lastNow = now;

      const elapsed = now - start;
      const uRaw = Math.min(elapsed / totalMs, 1);
      const eased = smooth01(uRaw);
      const u = easeOutEndU(eased);

      const dist = u * totalLen;
      let idx = 0;
      while (idx < lengths.length && lengths[idx] < dist) idx++;

      const t = idx / (lengths.length - 1);
      const t2 = Math.min(1, t + lookAheadU);

      let target = curve.getPointAt(t2);
      target = shapeTargetWithBounds(target, uRaw, c2, widths, bounds);

      if (Array.isArray(words) && words.length === meshes.length) {
        const currentTime = startTime + (uRaw * durationSec);
        for (let k = 0; k < words.length; k++) {
          if (currentTime >= Number(words[k].startTime ?? 0)) startReveal(meshes[k], now);
        }
      } else {
        const p = uRaw * (n - 1);
        const revealIdx = Math.min(n - 1, Math.floor(p + cfg.revealWordLead));
        for (let k = 0; k <= revealIdx; k++) startReveal(meshes[k], now);
      }

      for (const m of meshes) tickReveal(m, now);

      camX = damp(camX, target.x, followLambda, dt);
      camY = damp(camY, target.y, followLambda, dt);

      lookAtX = damp(lookAtX, target.x, cfg.lookAtLambda, dt);
      lookAtY = damp(lookAtY, target.y, cfg.lookAtLambda, dt);

      camera.position.set(camX, camY, cfg.cameraDistance);
      camera.lookAt(lookAtX, lookAtY, target.z);

      renderer.render(scene, camera);

      if (uRaw < 1) requestAnimationFrame(frame);
      else {
        for (const m of meshes) {
          m.visible = true;
          m.material.opacity = 1;
          m.userData.revealStart = null;
          m.scale.setScalar(1);
          m.position.copy(m.userData.basePos);
        }
        setTimeout(() => onComplete?.(), cfg.lineHoldMsAfterComplete);
      }
    }

    requestAnimationFrame(frame);
  }

  // -------------------------
  // Animation: fallback
  // -------------------------
  function animateLineGlideFallback(lineObj, onComplete){
    const { meshes, centers, widths, group } = lineObj;
    const n = centers.length;

    for (const m of meshes) {
      m.visible = false;
      m.material.opacity = 0;
      m.userData.revealStart = null;
      m.userData.revealed = false;
      m.scale.setScalar(1);
      m.position.copy(m.userData.basePos);
    }

    if (n === 0) { onComplete?.(); return; }

    const c2 = centersWithGroupY(centers, group.position.y);
    const curve = new THREE.CatmullRomCurve3(c2, false, 'catmullrom', 0.5);

    const bounds = computeCenterBounds(c2);

    const ARC_SAMPLES = Math.max(320, n * 120);
    const lengths = curve.getLengths(ARC_SAMPLES);
    const totalLen = lengths[lengths.length - 1];

    const totalMs = n * (1000 / cfg.wordsPerSecond);
    const start = performance.now();

    let camX = camera.position.x;
    let camY = camera.position.y;
    let lookAtX = camera.position.x;
    let lookAtY = camera.position.y;

    const revealWordLead = cfg.revealWordLead;
    const followLambda   = cfg.followLambda;
    const lookAheadU     = cfg.curveLookAheadU;
    let lastNow = performance.now();

    function frame(now){
      const dt = Math.max(0.001, (now - lastNow) / 1000);
      lastNow = now;

      const elapsed = now - start;
      const uRaw = Math.min(elapsed / totalMs, 1);
      const eased = smooth01(uRaw);
      const u = easeOutEndU(eased);

      const dist = u * totalLen;
      let idx = 0;
      while (idx < lengths.length && lengths[idx] < dist) idx++;

      const t = idx / (lengths.length - 1);
      const t2 = Math.min(1, t + lookAheadU);

      let target = curve.getPointAt(t2);
      target = shapeTargetWithBounds(target, uRaw, c2, widths, bounds);

      const p = uRaw * (n - 1);
      const revealIdx = Math.min(n - 1, Math.floor(p + revealWordLead));
      for (let k = 0; k <= revealIdx; k++) startReveal(meshes[k], now);

      for (const m of meshes) tickReveal(m, now);

      camX = damp(camX, target.x, followLambda, dt);
      camY = damp(camY, target.y, followLambda, dt);

      lookAtX = damp(lookAtX, target.x, cfg.lookAtLambda, dt);
      lookAtY = damp(lookAtY, target.y, cfg.lookAtLambda, dt);

      camera.position.set(camX, camY, cfg.cameraDistance);
      camera.lookAt(lookAtX, lookAtY, target.z);

      renderer.render(scene, camera);

      if (uRaw < 1) requestAnimationFrame(frame);
      else {
        for (const m of meshes) {
          m.visible = true;
          m.material.opacity = 1;
          m.userData.revealStart = null;
          m.scale.setScalar(1);
          m.position.copy(m.userData.basePos);
        }
        setTimeout(() => onComplete?.(), cfg.lineHoldMsAfterComplete);
      }
    }

    requestAnimationFrame(frame);
  }

  // -------------------------
  // Sequencer + stacking
  // -------------------------
  let isPlaying = false;

  function clearAllLinesFromScene() {
    for (const obj of lineObjs) {
      if (obj?.group) scene.remove(obj.group);
    }
    stackedLineCount = 0;
  }

  function enforceStackLimit() {
    if (!cfg.keepPreviousLinesVisible) return;
    if (!cfg.stackLines) return;
    const max = Math.max(1, Number(cfg.stackMaxLines || 1));

    while (stackedLineCount > max) {
      for (let i = 0; i < lineObjs.length; i++) {
        const g = lineObjs[i]?.group;
        if (g && g.parent === scene) {
          scene.remove(g);
          stackedLineCount--;
          break;
        }
      }
      if (stackedLineCount <= max) break;
    }
  }

  function positionGroupForStack(group) {
    if (!cfg.keepPreviousLinesVisible || !cfg.stackLines) {
      group.position.y = 0;
      return;
    }

    const gap = Number(cfg.stackLineGap || 0.22);
    if (cfg.stackAnchor === 'center') {
      group.position.y = 0 - (stackedLineCount * gap);
      return;
    }
    group.position.y = (stackedLineCount * gap);
  }

  function runSequence(lineIdx = 0) {
    if (lineIdx >= lineObjs.length) {
      isPlaying = false;
      setStatus(transcriptionData
        ? `Done. (Resolve) Lines: ${lineObjs.length}  Words: ${transcriptionData.words?.length ?? 0}`
        : `Done. (demo-lines.txt) Lines: ${lineObjs.length}`
      );
      return;
    }

    const current = lineObjs[lineIdx];

    if (cfg.keepPreviousLinesVisible && cfg.stackLines) {
      positionGroupForStack(current.group);
      stackedLineCount++;
      enforceStackLimit();
    } else {
      current.group.position.y = 0;
    }

    scene.add(current.group);

    const hasTiming = (typeof current.startTime === 'number' && typeof current.endTime === 'number');
    const done = () => {
      if (!cfg.keepPreviousLinesVisible) scene.remove(current.group);
      runSequence(lineIdx + 1);
    };

    if (hasTiming) animateLineGlideWithTiming(current, done);
    else animateLineGlideFallback(current, done);
  }

  function replay() {
    if (!fontRef) return;
    if (isPlaying) return;

    isPlaying = true;
    clearAllLinesFromScene();

    camera.position.set(0, 0, cfg.cameraDistance);
    camera.lookAt(new THREE.Vector3(0,0,0));
    render();

    runSequence(0);
  }

  function buildFromTimedLines(font, timedLines) {
    clearAllLinesFromScene();
    lineObjs = [];
    for (const ln of timedLines) {
      const obj = buildLine(font, ln.text);
      obj.startTime = ln.startTime;
      obj.endTime = ln.endTime;
      obj.words = ln.words;
      lineObjs.push(obj);
    }
  }

  function buildFromPlainLines(font, lines) {
    clearAllLinesFromScene();
    lineObjs = [];
    for (const l of lines) lineObjs.push(buildLine(font, l));
  }

  // -------------------------
  // Record / export
  // -------------------------
  let mediaRecorder = null;
  let recordedChunks = [];
  let recordingActive = false;

  function pickMimeType() {
    const candidates = ['video/webm;codecs=vp9','video/webm;codecs=vp8','video/webm'];
    for (const t of candidates) {
      if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t;
    }
    return '';
  }

  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 5000);
  }

  function startRecording() {
    if (recordingActive) return;
    if (!canvas.captureStream || !window.MediaRecorder) {
      setStatus('Recording not supported in this browser.\nTry Chrome/Edge on desktop.\n(iOS Safari often blocks WebM MediaRecorder)');
      return;
    }

    const stream = canvas.captureStream(60);
    const mimeType = pickMimeType();

    try {
      mediaRecorder = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
    } catch (e) {
      setStatus('MediaRecorder init failed:\n' + String(e));
      return;
    }

    recordedChunks = [];
    recordingActive = true;

    mediaRecorder.ondataavailable = (ev) => {
      if (ev.data && ev.data.size > 0) recordedChunks.push(ev.data);
    };

    mediaRecorder.onstop = () => {
      recordingActive = false;
      btnRecord.style.display = '';
      btnStop.style.display = 'none';

      const blob = new Blob(recordedChunks, { type: (mediaRecorder && mediaRecorder.mimeType) || 'video/webm' });
      recordedChunks = [];

      const stamp = new Date().toISOString().replace(/[:.]/g,'-');
      downloadBlob(blob, `captioner-${stamp}.webm`);
      setStatus('Saved recording to device downloads.\nIf you’re on iOS: you may need "Share → Save Video" depending on browser.');
    };

    mediaRecorder.start(250);
    btnRecord.style.display = 'none';
    btnStop.style.display = '';
    setStatus(`Recording…\nMime: ${mediaRecorder.mimeType || '(default)'}`);
  }

  function stopRecording() {
    if (!mediaRecorder || !recordingActive) return;
    try { mediaRecorder.stop(); } catch (e) { setStatus('Stop failed:\n' + String(e)); }
  }

  btnRecord.addEventListener('click', startRecording);
  btnStop.addEventListener('click', stopRecording);

  // -------------------------
  // Advanced cfg editor
  // -------------------------
  const CFG_SCHEMA = [
    ['textSize', 'number', 'textSize', 'word size in world units (rebuild needed)'],
    ['textDepth', 'number', 'textDepth', 'extrusion depth (rebuild needed)'],
    ['color', 'text', 'color', 'hex color (e.g. 0xffffff)'],
    ['cameraDistance', 'number', 'cameraDistance', 'z distance of camera'],
    ['wordsPerSecond', 'number', 'wordsPerSecond', 'fallback speed mode only'],
    ['curveLookAheadU', 'number', 'curveLookAheadU', '0.01..0.08 recommended'],
    ['followLambda', 'number', 'followLambda', '12 floaty, 35 tight'],
    ['lookAtLambda', 'number', 'lookAtLambda', 'softens look-at easing'],
    ['revealWordLead', 'number', 'revealWordLead', 'reveal early (fallback)'],
    ['spaceMultiplier', 'number', 'spaceMultiplier', 'inter-word spacing'],
    ['revealMs', 'number', 'revealMs', 'reveal anim duration ms'],
    ['revealPopScale', 'number', 'revealPopScale', 'pop scale'],
    ['revealRise', 'number', 'revealRise', 'rise offset'],
    ['revealZ', 'number', 'revealZ', 'z push'],
    ['revealOvershoot', 'number', 'revealOvershoot', 'back overshoot'],
    ['endOverhangFactor', 'number', 'endOverhangFactor', '× last-word width near end'],
    ['endOverhangPx', 'number', 'endOverhangPx', 'extra push in world units'],
    ['trackLeadPx', 'number', 'trackLeadPx', 'left clamp padding'],
    ['endOverhangBlendU', 'number', 'endOverhangBlendU', 'blend-in fraction near end'],
    ['endEaseOutU', 'number', 'endEaseOutU', 'slow end fraction'],
    ['lineHoldMsAfterComplete', 'number', 'lineHoldMsAfterComplete', 'ms pause after each line'],
    ['stackLines', 'text', 'stackLines', 'true/false (when keepPrev true)'],
    ['stackLineGap', 'number', 'stackLineGap', 'vertical gap between stacked lines'],
    ['stackAnchor', 'text', 'stackAnchor', 'bottom or center'],
    ['stackMaxLines', 'number', 'stackMaxLines', 'max stacked lines visible']
  ];

  const cfgInputs = new Map();

  function buildCfgEditorUI() {
    cfgGrid.innerHTML = '';
    cfgInputs.clear();

    for (const [key, type, label, help] of CFG_SCHEMA) {
      const row = document.createElement('div');
      row.className = 'cfgrow';

      const lab = document.createElement('label');
      lab.textContent = label;

      const sm = document.createElement('small');
      sm.textContent = help;
      lab.appendChild(sm);

      const input = document.createElement('input');
      input.type = (type === 'number') ? 'number' : 'text';
      input.step = (type === 'number') ? 'any' : undefined;

      input.placeholder = String(DEFAULT_CFG[key] ?? '');
      input.value = '';

      row.appendChild(lab);
      row.appendChild(input);
      cfgGrid.appendChild(row);

      cfgInputs.set(key, input);
    }
  }

  function applyCfgFromInputs() {
    for (const [key, input] of cfgInputs.entries()) {
      const raw = (input.value ?? '').trim();
      if (!raw) { cfg[key] = DEFAULT_CFG[key]; continue; }

      const spec = CFG_SCHEMA.find(x => x[0] === key);
      const type = spec ? spec[1] : 'text';

      if (type === 'number') {
        const v = Number(raw);
        if (!isFinite(v)) { setStatus(`cfg apply error:\n${key} must be a number`); return false; }
        cfg[key] = v;
      } else {
        if (raw.toLowerCase() === 'true') cfg[key] = true;
        else if (raw.toLowerCase() === 'false') cfg[key] = false;
        else cfg[key] = raw;
      }
    }

    keepPrevEl.checked = !!cfg.keepPreviousLinesVisible;
    ohValEl.textContent = Number(cfg.endOverhangFactor).toFixed(2);
    ohEl.value = String(cfg.endOverhangFactor);

    baseMat = createBaseMaterial();

    return true;
  }

  function resetCfgInputs() {
    for (const [key, input] of cfgInputs.entries()) {
      input.value = '';
      input.placeholder = String(DEFAULT_CFG[key] ?? '');
    }
    Object.assign(cfg, structuredClone(DEFAULT_CFG));
    keepPrevEl.checked = !!cfg.keepPreviousLinesVisible;
    ohEl.value = String(cfg.endOverhangFactor);
    ohValEl.textContent = Number(cfg.endOverhangFactor).toFixed(2);
    setStatus('cfg reset to defaults.\n(Rebuild on Replay)');
  }

  cfgResetBtn.addEventListener('click', () => resetCfgInputs());

  async function rebuildSceneFromCurrentSource() {
    if (!fontRef) return;

    if (transcriptionData && Array.isArray(transcriptionData.words) && transcriptionData.words.length) {
      const wpl = Number(wplEl.value);
      const timedLines = transcriptionToTimedLines(transcriptionData, wpl);
      buildFromTimedLines(fontRef, timedLines);
      return;
    }

    const lines = await loadLines(cfg.linesUrl);
    buildFromPlainLines(fontRef, lines);
  }

  cfgApplyBtn.addEventListener('click', () => {
    const ok = applyCfgFromInputs();
    if (!ok) return;

    setStatus('cfg applied.\nRebuilding scene…');
    rebuildSceneFromCurrentSource().then(() => {
      setStatus('cfg applied + rebuilt.\nReplaying…');
      replay();
    }).catch(err => {
      setStatus('cfg rebuild failed:\n' + String(err));
    });
  });

  // -------------------------
  // Buttons
  // -------------------------
  btnLoad.addEventListener('click', async () => {
    if (!fontRef) { setStatus('Font not loaded yet.'); return; }

    setStatus('Loading transcription from Resolve…');
    const data = await loadTranscriptionFromResolve();

    if (data?.error) {
      setStatus(`Resolve error:\n${data.error}\n${data.instructions ? '\n' + data.instructions : ''}`);
      return;
    }

    transcriptionData = data;
    const wpl = Number(wplEl.value);
    const timedLines = transcriptionToTimedLines(data, wpl);

    if (!timedLines.length) {
      setStatus('Loaded transcription, but got 0 lines.\nAre subtitle items / word timings available?');
      return;
    }

    buildFromTimedLines(fontRef, timedLines);
    setStatus(`✓ Loaded Resolve transcript\nClip: ${data.clipName ?? '(unknown)'}\nWords: ${data.words?.length ?? 0}\nLines: ${timedLines.length}`);
    replay();
  });

  btnReplay.addEventListener('click', () => {
    setStatus('Replaying…');
    replay();
  });

  btnCreate.addEventListener('click', async () => {
    if (!transcriptionData?.words?.length) { setStatus('Load from Resolve first.'); return; }

    const wpl = Number(wplEl.value);
    setStatus('Creating captions in Resolve…');

    try {
      const res = await fetch('/api/create-animated-captions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ words: transcriptionData.words, wordsPerLine: wpl })
      });

      const out = await res.json();
      if (out?.error) { setStatus(`Create captions error:\n${out.error}`); return; }

      setStatus(`✓ Created captions in Resolve: ${out.created ?? 0}`);
    } catch (e) {
      setStatus(`Create captions failed:\n${String(e)}`);
    }
  });

  // -------------------------
  // Boot
  // -------------------------
  buildCfgEditorUI();
  keepPrevEl.checked = !!cfg.keepPreviousLinesVisible;

  new THREE.FontLoader().load(
    'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json',
    async (font) => {
      fontRef = font;

      // try Resolve first (silent)
      const data = await loadTranscriptionFromResolve();
      if (data && !data.error && Array.isArray(data.words) && data.words.length) {
        transcriptionData = data;
        const wpl = Number(wplEl.value);
        const timedLines = transcriptionToTimedLines(data, wpl);
        if (timedLines.length) {
          buildFromTimedLines(font, timedLines);
          setStatus(`Auto-loaded Resolve transcript\nWords: ${data.words.length}\nLines: ${timedLines.length}`);
          replay();
          return;
        }
      }

      // fallback to demo-lines.txt
      try {
        const lines = await loadLines(cfg.linesUrl);
        buildFromPlainLines(font, lines);

        camera.position.set(0, 0, cfg.cameraDistance);
        camera.lookAt(new THREE.Vector3(0,0,0));
        render();

        setStatus(`Loaded fallback demo-lines.txt\nLines: ${lines.length}`);
        replay();
      } catch (e) {
        setStatus(`Boot error:\n${String(e)}`);
      }
    },
    undefined,
    (err) => setStatus('Font load failed: ' + String(err))
  );

  // -------------------------
  // Resize
  // -------------------------
  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    render();
  });
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
  <title>3D Glide-Over-Line Captioner (Resolve Transcript Sync)</title>
  <style>
    :root {
      --ui-width: clamp(280px, 30vw, 340px);
    }

    html, body { margin:0; padding:0; width:100%; height:100%; background:#000; overflow:hidden; overscroll-behavior: none; }
    canvas { width:100%; height:100%; display:block; }

    #ui {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 9999;
      background: rgba(0,0,0,0.78);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 12px;
      border-radius: 12px;
      color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: 12px;
      width: var(--ui-width);
      max-height: calc(100vh - 20px);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      user-select: none;
      box-shadow: 0 10px 40px rgba(0,0,0,0.45);
      backdrop-filter: blur(6px);
      transition: transform 160ms ease, opacity 160ms ease;
    }

    /* collapsed state: tuck it mostly offscreen but keep a tab */
    #ui.collapsed {
      transform: translateX(calc(var(--ui-width) - 68px));
      opacity: 0.92;
    }

    /* header with collapse toggle */
    #uiHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 6px;
    }

    #uiTitle {
      font-weight: 900;
      font-size: 13px;
      line-height: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #uiToggle {
      width: 38px;
      height: 28px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.08);
      color: #fff;
      cursor: pointer;
      font-weight: 900;
      display: grid;
      place-items: center;
      user-select: none;
    }

    /* when collapsed, hide all content except header (and make header look like a tab) */
    #ui.collapsed #uiBody { display: none; }
    #ui.collapsed {
      padding: 10px 8px;
      width: var(--ui-width); /* keep same width for consistent slide */
    }
    #ui.collapsed #uiHeader {
      margin-bottom: 0;
    }
    #ui.collapsed #uiTitle {
      opacity: 0.85;
      font-size: 12px;
    }

    #ui button {
      width: 100%;
      padding: 10px 10px;
      margin: 6px 0;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 800;
      letter-spacing: 0.2px;
    }

    #btnLoad   { background: #00ccff; color:#001018; }
    #btnCreate { background: #4caf50; color:#fff; }
    #btnReplay { background: #303030; color:#fff; }
    #btnRecord { background: #ff3b30; color:#fff; }
    #btnStop   { background: #ff9500; color:#111; display:none; }

    #ui label { display:block; margin-top:10px; opacity: 0.95; }
    #ui input[type="range"] { width: 100%; margin-top: 6px; }
    #ui input[type="checkbox"] { transform: translateY(1px); }
    #ui .row { display:flex; gap:8px; }
    #ui .row button { width: 50%; }
    #ui .row.tight button { width: auto; flex: 1; }
    #ui .row.wrap { flex-wrap: wrap; }
    #ui .row.wrap button { flex: 1 1 48%; }

    #status {
      margin-top: 8px;
      line-height: 1.35;
      opacity: 0.92;
      white-space: pre-wrap;
    }
    #hint { opacity:0.7; margin-top:6px; }
    #mini { margin-top: 8px; opacity: 0.75; font-size: 11px; line-height: 1.25; }
    #mini code { opacity: 0.9; }

    #uiBody {
      flex: 1;
      overflow-y: auto;
      padding-right: 4px;
      -webkit-overflow-scrolling: touch;
    }

    #uiBody::-webkit-scrollbar { width: 8px; }
    #uiBody::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.18); border-radius: 999px; }
    #uiBody::-webkit-scrollbar-track { background: transparent; }

    /* Config panel */
    details.cfgbox {
      margin-top: 10px;
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      overflow: hidden;
      background: rgba(255,255,255,0.03);
    }
    details.cfgbox > summary {
      list-style: none;
      cursor: pointer;
      padding: 10px 10px;
      font-weight: 850;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      background: rgba(0,0,0,0.18);
    }
    details.cfgbox > summary::-webkit-details-marker { display:none; }
    .pill {
      font-size: 11px;
      opacity: 0.75;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.28);
    }
    .cfggrid {
      padding: 10px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }
    .cfgrow {
      display: grid;
      grid-template-columns: 1fr 110px;
      gap: 8px;
      align-items: center;
    }
    .cfgrow label {
      margin: 0;
      opacity: 0.9;
      font-weight: 650;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .cfgrow small {
      opacity: 0.65;
      font-weight: 500;
      line-height: 1.1;
    }
    .cfgrow input[type="number"],
    .cfgrow input[type="text"] {
      width: 100%;
      padding: 8px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.30);
      color: #fff;
      outline: none;
    }
    .cfgrow input::placeholder { color: rgba(255,255,255,0.35); }
    .cfgactions {
      padding: 10px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      border-top: 1px solid rgba(255,255,255,0.08);
      background: rgba(0,0,0,0.12);
    }
    .cfgactions button {
      margin: 0;
      padding: 10px;
      border-radius: 10px;
      background: rgba(255,255,255,0.10);
      color: #fff;
    }
    .cfgactions button.primary {
      background: rgba(0, 204, 255, 0.85);
      color: #06141a;
    }

    .panel {
      margin-top: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 10px;
      background: rgba(255,255,255,0.03);
    }

    .panel h4 {
      margin: 0 0 8px;
      font-size: 12px;
      font-weight: 800;
      opacity: 0.9;
    }

    .panel .muted {
      opacity: 0.7;
      font-size: 11px;
    }

    .panel .caption-box {
      margin-top: 8px;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
      font-size: 12px;
      line-height: 1.3;
      white-space: pre-wrap;
      min-height: 44px;
    }

    .panel .inline-input {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .panel input[type="text"],
    .panel input[type="number"] {
      width: 100%;
      padding: 8px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.30);
      color: #fff;
      outline: none;
    }

    .panel .radio-row {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }

    .panel .radio-row label {
      margin: 0;
      display: flex;
      gap: 6px;
      align-items: center;
      font-weight: 700;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      padding: 6px;
      border: 1px solid rgba(255,255,255,0.08);
    }

    .panel .progress {
      margin-top: 8px;
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.12);
      overflow: hidden;
    }

    .panel .progress span {
      display: block;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #00ccff, #4caf50);
      transition: width 120ms ease;
    }

    .panel .link {
      color: #7fe9ff;
      word-break: break-all;
    }

    @media (max-width: 900px) {
      :root { --ui-width: clamp(280px, 44vw, 360px); }
      #ui { right: 8px; top: 8px; max-height: calc(100vh - 16px); }
      #ui.collapsed { transform: translateX(calc(var(--ui-width) - 64px)); }
    }

    @media (max-width: 720px), (orientation: portrait) {
      :root { --ui-width: calc(100vw - 24px); }
      #ui {
        left: 12px;
        right: 12px;
        top: 12px;
        width: var(--ui-width);
        max-height: calc(100vh - 24px);
      }
      #ui.collapsed {
        transform: translateY(calc(100% - 64px));
      }
    }

    @media (orientation: landscape) and (max-height: 520px) {
      #ui { top: 8px; right: 8px; max-height: calc(100vh - 12px); }
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>

  <div id="ui" class="collapsed">
    <div id="uiHeader">
      <div id="uiTitle">Resolve Transcript Sync</div>
      <button id="uiToggle" title="Collapse/Expand">◀</button>
    </div>

    <div id="uiBody">
    <details class="cfgbox" id="workspacePanel" open>
      <summary>Workspace</summary>
      <label>
        Project
        <select id="projectSelect"></select>
      </label>
      <label>
        Video
        <select id="videoSelect"></select>
      </label>
      <button id="btnGenerateCaptions">Generate Captions</button>
      <small id="workspaceStatus">Pick a project to list media.</small>
    </details>

    <div class="panel" id="captionSourcePanel">
      <h4>Caption Source</h4>
      <div class="radio-row">
        <label><input type="radio" name="captionSource" value="lines" checked /> Lines</label>
        <label><input type="radio" name="captionSource" value="srt" /> SRT</label>
        <label><input type="radio" name="captionSource" value="cues" /> Cues</label>
      </div>
      <label>
        Media URL (for SRT/Cues)
        <input id="mediaUrlInput" type="text" placeholder="http://192.168.0.25:8787/media/.../clip.mp4" />
      </label>
      <div class="row tight">
        <button id="btnLoadCaptionSource">Load Caption Source</button>
        <button id="btnClearCaptionSource">Clear</button>
      </div>
      <small class="muted">Lines mode uses cfg.linesUrl. SRT/Cues mode resolves from the media URL.</small>
    </div>

    <div class="panel" id="timelinePanel">
      <h4>Timeline</h4>
      <div class="inline-input">
        <div id="timelineTimecode">00:00.000</div>
        <div class="muted" id="timelineDuration">/ 00:00.000</div>
      </div>
      <input id="timelineRange" type="range" min="0" max="1000" step="1" value="0" />
      <div class="row tight">
        <button id="btnTimelinePlay">Play</button>
        <button id="btnTimelinePause">Pause</button>
        <button id="btnTimelineReplay">Replay</button>
      </div>
      <div class="caption-box" id="activeCaptionPreview">Active caption will appear here.</div>
    </div>

    <div class="panel" id="syncPanel">
      <h4>Sync</h4>
      <label style="display:flex; align-items:center; gap:8px;">
        <input id="applyOffset" type="checkbox" />
        Apply offset
      </label>
      <label>
        Offset (ms)
        <input id="offsetMsInput" type="number" step="10" value="0" />
      </label>
      <div class="row tight">
        <button id="offsetBack">-250ms</button>
        <button id="offsetForward">+250ms</button>
      </div>
      <small class="muted">Use offsets to sync captions with playback or Resolve timing.</small>
    </div>

    <div class="panel" id="exportPanel">
      <h4>Export</h4>
      <button id="btnRenderVertical">Render Vertical (server)</button>
      <div class="row wrap">
        <button id="btnRecord">Record Canvas (WebM)</button>
        <button id="btnStop">Stop Recording</button>
      </div>
      <div class="progress"><span id="renderProgress"></span></div>
      <div class="muted" id="renderStatus">Server render job idle.</div>
      <a id="renderDownload" class="link" target="_blank" rel="noopener"></a>
    </div>

      <button id="btnLoad">Load from Resolve</button>
      <button id="btnReplay">Replay</button>
      <button id="btnCreate">Create Captions in Resolve</button>

    <label>
      Words per line: <span id="wplVal">8</span>
      <input id="wpl" type="range" min="3" max="14" step="1" value="8" />
    </label>

    <label>
      Font preset
      <select id="fontSelect"></select>
    </label>

    <label>
      Typography profile
      <select id="typographyProfile"></select>
      <small>Applies the TYPOGRAPHY.md spacing + depth presets.</small>
    </label>

    <label>
      Custom font URL (TTF/OTF or typeface JSON)
      <input id="fontUrl" type="text" placeholder="https://…" />
      <small>Used when "Custom URL" is selected. Requires CORS access.</small>
    </label>

      <label>
        Reveal style
        <select id="revealStyle"></select>
      </label>

      <label>
        Line alignment
        <select id="textAlign">
          <option value="center">Center (default)</option>
          <option value="left">Left</option>
          <option value="right">Right</option>
        </select>
        <small>Anchor words left/center/right around the origin. Rebuild on Replay.</small>
      </label>

      <label>
        Background theme
        <select id="themeSelect"></select>
      </label>

    <label>
      Emphasis profile
      <select id="emphasisProfile"></select>
    </label>

    <label>
      End overhang: <span id="ohVal">0.65</span> (× last-word width)
      <input id="oh" type="range" min="0" max="1" step="0.05" value="0.65" />
    </label>

    <label style="display:flex; align-items:center; gap:10px;">
      <input id="keepPrev" type="checkbox" />
      keepPreviousLinesVisible
    </label>

    <details class="cfgbox" id="cfgDetails">
      <summary>
        <span>Advanced cfg</span>
        <span class="pill" id="cfgPill">collapsed</span>
      </summary>

      <div class="cfggrid" id="cfgGrid"></div>

      <div class="cfgactions">
        <button id="cfgReset">Reset</button>
        <button class="primary" id="cfgApply">Apply</button>
      </div>
    </details>

    <div id="status">Idle.</div>
    <div id="hint">Tip: In Resolve, select a clip → right-click → Transcribe Audio.</div>
    <div id="mini">
      Export note: recording uses <code>canvas.captureStream</code> + <code>MediaRecorder</code>.
      Some iOS browsers may block WebM recording.
      Script tokens: <code>#A/#B/#C</code> switch profiles, <code>#default</code> resets to base; <code>[PAUSE=ms]</code> / <code>[HOLD=ms]</code> apply to the next line; <code>[BREAK]</code> adds a blank paragraph gap before the next caption.
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/TTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
<script src="./animation-helpers.js"></script>
<script src="./lighting-rig.js"></script>

<script>
  // -------------------------
  // CONFIG (defaults)
  // -------------------------
  const DEFAULT_CFG = Object.freeze({
    linesUrl: './demo-lines.txt',

    fontId: 'helvetiker',
    fontUrl: 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json',
    fontFormat: 'typeface',

      typographyProfile: (window.AnimationHelpers?.DEFAULT_TYPOGRAPHY_PROFILE_ID) || 'manual',

      textSize:  0.10,
      textDepth: 0.001,
      textAlign: 'center',

      theme: 'light',
      backgroundColor: 0xffffff,
      color:     0x000000,
    cameraDistance: 3.5,

    wordsPerSecond:  2.5,
    curveLookAheadU: 0.045,
    followLambda:    13.5,
    lookAtLambda:    9.5,
    revealWordLead:  1.15,

    spaceMultiplier: 1.82,

    revealMs:         240,
    revealStartScale: 1.04,
    revealPopScale:   1.07,
    revealRise:       0.045,
    revealZ:          0.05,
    revealOvershoot:  0.02,
    revealStyle:      'slide-up',

    emphasisProfile:  'documentary',

    endOverhangFactor: 0.65,
    endOverhangPx:     0.16,
    trackLeadPx:       0.06,
    endOverhangBlendU: 0.10,
    endEaseOutU:       0.14,

    // Highlight smoothing (kept internal; UI remains uncluttered)
    highlightLambda: 12,
    neighborHighlight: 0.35,
    activeGlowBoost: 0.22,
    neighborGlowBoost: 0.12,

    keepPreviousLinesVisible: false,
    lineHoldMsAfterComplete:  620,

    stackLines: true,
    stackLineGap: 0.22,
    stackAnchor: 'bottom',
    stackMaxLines: 6,

    paragraphGap: 0.32
  });

  const DEFAULT_CAPTION_SOURCE = Object.freeze({
    mode: 'lines',
    mediaUrl: '',
    applyOffset: true,
    offsetMs: 0,
  });

  const STORAGE_KEY = 'captioner_state_v1';
  const STORAGE_SEED_URLS = ['./localStorage.json', './alternate-test-versions/localStorage.json'];
  const FALLBACK_DEMO_LINES = [
    'Cinematic scripting starts in default (no marker required)',
    '[BREAK]',
    '#A Calm dolly profile slows the follow and softens reveals',
    '[PAUSE=220]',
    '#B Assertive pacing tightens follow and pops punctuation',
    '[HOLD=320]',
    '#C Dramatic settle widens the lens and lingers on the last word',
    '#default Return to the default glide once the moods finish'
  ];

  const DEFAULT_LINE_PROFILE_ID = 'default';

  const LINE_PROFILE_PRESETS = {
    default: {
      label: 'Default glide',
      speedMultiplier: 1,
      followMult: 1,
      lookAtMult: 1,
      lookAheadOffset: 0,
      cameraDistanceOffset: 0,
      holdMs: 0,
      revealStyle: null,
      endBiasPx: 0,
    },
    A: {
      label: 'Profile A (calm dolly)',
      speedMultiplier: 0.9,
      followMult: 0.86,
      lookAtMult: 0.9,
      lookAheadOffset: -0.006,
      cameraDistanceOffset: 0.1,
      holdMs: 160,
      revealStyle: 'grow-up',
      endBiasPx: 0.025,
    },
    B: {
      label: 'Profile B (tight + assertive)',
      speedMultiplier: 1.12,
      followMult: 1.18,
      lookAtMult: 1.1,
      lookAheadOffset: 0.014,
      cameraDistanceOffset: -0.07,
      holdMs: 90,
      revealStyle: 'slide-up',
      endBiasPx: 0.05,
    },
    C: {
      label: 'Profile C (dramatic settle)',
      speedMultiplier: 0.82,
      followMult: 0.8,
      lookAtMult: 0.88,
      lookAheadOffset: -0.015,
      cameraDistanceOffset: 0.16,
      holdMs: 260,
      revealStyle: 'grow-up',
      endBiasPx: 0.07,
    }
  };

  const FONT_PRESETS = [
    {
      id: 'helvetiker',
      label: 'Helvetiker (Three default)',
      url: DEFAULT_CFG.fontUrl,
      format: 'typeface'
    },
    {
      id: 'bebas-neue',
      label: 'Bebas Neue (Action, CDN)',
      url: 'https://raw.githubusercontent.com/google/fonts/main/ofl/bebasneue/BebasNeue-Regular.ttf',
      format: 'ttf'
    },
    {
      id: 'montserrat',
      label: 'Montserrat Variable (CDN)',
      url: 'https://raw.githubusercontent.com/google/fonts/main/ofl/montserrat/Montserrat%5Bwght%5D.ttf',
      format: 'ttf'
    },
    {
      id: 'cinzel',
      label: 'Cinzel Variable (CDN)',
      url: 'https://raw.githubusercontent.com/google/fonts/main/ofl/cinzel/Cinzel%5Bwght%5D.ttf',
      format: 'ttf'
    },
    {
      id: 'playfair-display',
      label: 'Playfair Display Variable (CDN)',
      url: 'https://raw.githubusercontent.com/google/fonts/main/ofl/playfairdisplay/PlayfairDisplay%5Bwght%5D.ttf',
      format: 'ttf'
    },
    {
      id: 'orbitron',
      label: 'Orbitron Variable (CDN)',
      url: 'https://raw.githubusercontent.com/google/fonts/main/ofl/orbitron/Orbitron%5Bwght%5D.ttf',
      format: 'ttf'
    },
    {
      id: 'custom',
      label: 'Custom URL (set below)',
      url: '',
      format: 'auto'
    }
  ];

  const REVEAL_STYLE_OPTIONS = [
    { id: 'slide-up', label: 'Slide up (default)' },
    { id: 'grow-up', label: 'Grow from below / behind' },
    { id: 'bloom', label: 'Word bloom (soft scale pop)' },
    { id: 'fade-scale', label: 'Fade + scale in' },
    { id: 'word-fade', label: 'Word fade in' },
    { id: 'char-fade', label: 'Character fade in' },
    { id: 'typewriter', label: 'Character typewriter sweep' }
  ];

  const THEME_OPTIONS = [
    { id: 'light', label: 'Light (white bg, black text)', background: 0xffffff, text: 0x000000 },
    { id: 'dark', label: 'Dark (black bg, white text)', background: 0x000000, text: 0xffffff },
  ];

  const EMPHASIS_PROFILE_OPTIONS = [
    { id: 'documentary', label: 'Documentary (semantic + terminal stack)' },
    { id: 'minimal', label: 'Minimal (baseline only)' }
  ];

  const DEFAULT_TYPOGRAPHY_PROFILE_ID = AnimationHelpers?.DEFAULT_TYPOGRAPHY_PROFILE_ID || 'manual';
  const TYPOGRAPHY_PROFILE_OPTIONS = Object.values(AnimationHelpers?.TYPOGRAPHY_PROFILES || {})
    .map(p => ({ id: p.id, label: p.label || p.id }))
    .sort((a, b) => a.label.localeCompare(b.label));

  const EMPHASIS_PROFILES = {
    documentary: {
      label: 'Documentary',
      emphasisScale: 1.08,
      emphasisSettleMs: 260,
      emphasisDriftFrac: 0.08,
      emphasisHoldMs: 120,
      emphasisFollowMult: 0.72,
      emphasisLookAtMult: 0.75,
      terminalDriftFrac: 0.45,
      terminalHoldMs: 300,
      terminalFollowMult: 0.80,
      terminalLookAtMult: 0.85
    },
    minimal: {
      label: 'Minimal',
      emphasisScale: 1.0,
      emphasisSettleMs: 0,
      emphasisDriftFrac: 0,
      emphasisHoldMs: 0,
      emphasisFollowMult: 1,
      emphasisLookAtMult: 1,
      terminalDriftFrac: 0.25,
      terminalHoldMs: 160,
      terminalFollowMult: 0.92,
      terminalLookAtMult: 0.92
    }
  };

  const cfg = structuredClone(DEFAULT_CFG);

  // -------------------------
  // THREE SETUP
  // -------------------------
  const canvas   = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(cfg.backgroundColor);

  const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.05, 200);
  scene.add(camera);

  const lightingRig = (window.CaptionLighting || {}).applyLightingRig?.({
    THREE,
    scene,
    camera,
    palette: { text: cfg.color, background: cfg.backgroundColor },
  });

  function createTextNoiseTexture(size = 64) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    const image = ctx.createImageData(size, size);
    for (let i = 0; i < image.data.length; i += 4) {
      const n = Math.floor(200 + Math.random() * 55);
      image.data[i] = n;
      image.data[i + 1] = n;
      image.data[i + 2] = n;
      image.data[i + 3] = 255;
    }
    ctx.putImageData(image, 0, 0);

    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(6, 6);
    tex.minFilter = THREE.LinearFilter;
    tex.magFilter = THREE.LinearFilter;
    return tex;
  }

  const textNoiseTexture = createTextNoiseTexture();

  function applyTextShaderEffect(material) {
    if (!material || material.userData?.shaderEnhanced) return;
    material.userData.shaderEnhanced = true;

    material.onBeforeCompile = (shader) => {
      shader.uniforms.uNoiseMap = { value: textNoiseTexture };
      shader.uniforms.uNoiseStrength = { value: 0.08 };
      shader.uniforms.uNoiseScale = { value: 1.0 };

      const patched = AnimationHelpers.patchNoiseShaderSources(
        shader.vertexShader,
        shader.fragmentShader
      );
      shader.vertexShader = patched.vertexShader;
      shader.fragmentShader = patched.fragmentShader;

      material.userData.shader = shader;
    };

    material.needsUpdate = true;
  }

  function createBaseMaterial(isEmphasis = false) {
    if (lightingRig?.buildMaterialParams) {
      const mat = new THREE.MeshStandardMaterial(lightingRig.buildMaterialParams(cfg.color, { emphasis: isEmphasis }));
      applyTextShaderEffect(mat);
      return mat;
    }
    const mat = new THREE.MeshStandardMaterial({
      color: cfg.color,
      emissive: cfg.color,
      emissiveIntensity: isEmphasis ? 0.35 : 0.18,
      metalness: 0.05,
      roughness: isEmphasis ? 0.38 : 0.44,
      transparent: true,
      opacity: 1,
    });
    applyTextShaderEffect(mat);
    return mat;
  }

  let baseMat = createBaseMaterial();

  function refreshAllMeshMaterials() {
    baseMat = createBaseMaterial();
    for (const obj of lineObjs) {
      if (!obj?.meshes) continue;
      for (const m of obj.meshes) {
        if (!m?.material) continue;
        applyMaterialTone(m.material, !!m.userData?.emphasis);
      }
    }
  }

  function applyMaterialTone(mat, isEmphasis = false) {
    if (lightingRig?.tintMaterial) {
      lightingRig.tintMaterial(mat, cfg.color, { emphasis: isEmphasis });
      applyTextShaderEffect(mat);
      return;
    }
    if (!mat) return;
    const params = lightingRig?.buildMaterialParams?.(cfg.color, { emphasis: isEmphasis }) || {};
    if (mat.color?.set) mat.color.set(params.color ?? cfg.color);
    if (mat.emissive?.set) mat.emissive.set(params.emissive ?? cfg.color);
    mat.emissiveIntensity = params.emissiveIntensity ?? (isEmphasis ? 0.35 : 0.18);
    mat.metalness = params.metalness ?? 0.05;
    mat.roughness = params.roughness ?? (isEmphasis ? 0.38 : 0.44);
    mat.opacity = params.opacity ?? 1;
    mat.transparent = params.transparent ?? true;
    mat.needsUpdate = true;
    applyTextShaderEffect(mat);
  }

  let lineObjs = [];
  let lineImportStats = { rawLineCount: 0, segmentCount: 0 };
  let transcriptionData = null;
  let fontRef = null;
  const WORKSPACE_DEFAULT = Object.freeze({ project: '', video: '' });
  let workspaceState = { ...WORKSPACE_DEFAULT };
  let captionSourceState = { ...DEFAULT_CAPTION_SOURCE };
  let timelineState = {
    durationMs: 0,
    currentMs: 0,
    isPlaying: false,
    activeIndex: -1,
  };
  let timelineLines = [];
  let timelineLineSource = [];
  let timelineRafId = null;
  let timelineLastTick = null;
  let timelineStopCallback = null;

  let stackedLineCount = 0;
  const stackedGroups = [];
  const tmpBox = new THREE.Box3();

  // -------------------------
  // UI refs
  // -------------------------
  const ui = document.getElementById('ui');
  const uiToggle = document.getElementById('uiToggle');

  const statusEl = document.getElementById('status');
  const projectSelect = document.getElementById('projectSelect');
  const videoSelect = document.getElementById('videoSelect');
  const btnGenerateCaptions = document.getElementById('btnGenerateCaptions');
  const workspaceStatusEl = document.getElementById('workspaceStatus');
  const captionSourceRadios = Array.from(document.querySelectorAll('input[name="captionSource"]'));
  const mediaUrlInput = document.getElementById('mediaUrlInput');
  const btnLoadCaptionSource = document.getElementById('btnLoadCaptionSource');
  const btnClearCaptionSource = document.getElementById('btnClearCaptionSource');
  const timelineTimecodeEl = document.getElementById('timelineTimecode');
  const timelineDurationEl = document.getElementById('timelineDuration');
  const timelineRangeEl = document.getElementById('timelineRange');
  const btnTimelinePlay = document.getElementById('btnTimelinePlay');
  const btnTimelinePause = document.getElementById('btnTimelinePause');
  const btnTimelineReplay = document.getElementById('btnTimelineReplay');
  const activeCaptionPreview = document.getElementById('activeCaptionPreview');
  const applyOffsetEl = document.getElementById('applyOffset');
  const offsetMsInput = document.getElementById('offsetMsInput');
  const offsetBackBtn = document.getElementById('offsetBack');
  const offsetForwardBtn = document.getElementById('offsetForward');
  const btnRenderVertical = document.getElementById('btnRenderVertical');
  const renderProgressEl = document.getElementById('renderProgress');
  const renderStatusEl = document.getElementById('renderStatus');
  const renderDownloadEl = document.getElementById('renderDownload');
  const wplEl = document.getElementById('wpl');
  const wplValEl = document.getElementById('wplVal');
  const ohEl = document.getElementById('oh');
  const ohValEl = document.getElementById('ohVal');
  const fontSelect = document.getElementById('fontSelect');
  const typographyProfileSelect = document.getElementById('typographyProfile');
  const fontUrlInput = document.getElementById('fontUrl');
  const revealStyleSelect = document.getElementById('revealStyle');
  const textAlignSelect = document.getElementById('textAlign');
  const themeSelect = document.getElementById('themeSelect');
  const emphasisProfileSelect = document.getElementById('emphasisProfile');
  const keepPrevEl = document.getElementById('keepPrev');

  const btnLoad = document.getElementById('btnLoad');
  const btnReplay = document.getElementById('btnReplay');
  const btnCreate = document.getElementById('btnCreate');
  const btnRecord = document.getElementById('btnRecord');
  const btnStop = document.getElementById('btnStop');

  const cfgDetails = document.getElementById('cfgDetails');
  const cfgPill = document.getElementById('cfgPill');
  const cfgGrid = document.getElementById('cfgGrid');
  const cfgResetBtn = document.getElementById('cfgReset');
  const cfgApplyBtn = document.getElementById('cfgApply');

  function setStatus(msg) { statusEl.textContent = msg; }

  btnStop.style.display = 'none';
  btnRecord.disabled = false;
  btnStop.disabled = true;

  // Collapsible main UI panel
  function setUiCollapsed(isCollapsed) {
    ui.classList.toggle('collapsed', !!isCollapsed);
    uiToggle.textContent = isCollapsed ? '◀' : '▶';
    uiToggle.title = isCollapsed ? 'Expand' : 'Collapse';
    try { localStorage.setItem('captioner_ui_collapsed', isCollapsed ? '1' : '0'); } catch (_) {}
  }

  uiToggle.addEventListener('click', () => {
    setUiCollapsed(!ui.classList.contains('collapsed'));
  });

  // restore collapsed state (default collapsed)
  try {
    const v = localStorage.getItem('captioner_ui_collapsed');
    setUiCollapsed(v === null ? true : (v === '1'));
  } catch (_) {
    setUiCollapsed(true);
  }

  wplEl.addEventListener('input', () => {
    wplValEl.textContent = String(wplEl.value);
    persistState();
  });

  ohEl.value = String(cfg.endOverhangFactor);
  ohValEl.textContent = Number(cfg.endOverhangFactor).toFixed(2);

  ohEl.addEventListener('input', () => {
    const v = Number(ohEl.value);
    cfg.endOverhangFactor = v;
    ohValEl.textContent = v.toFixed(2);
    persistState();
  });

  keepPrevEl.addEventListener('change', () => {
    cfg.keepPreviousLinesVisible = !!keepPrevEl.checked;
    setStatus('Applied keepPreviousLinesVisible: ' + cfg.keepPreviousLinesVisible + '\n(Rebuild on Replay)');
    persistState();
  });

  projectSelect?.addEventListener('change', async () => {
    workspaceState.project = projectSelect.value || '';
    workspaceState.video = '';
    syncWorkspaceInputs();
    persistState();
    await refreshVideos(workspaceState.project);
  });

  videoSelect?.addEventListener('change', () => {
    workspaceState.video = videoSelect.value || '';
    syncWorkspaceInputs();
    persistState();
  });

  btnGenerateCaptions?.addEventListener('click', () => generateWorkspaceCaptions());

  captionSourceRadios.forEach(radio => {
    radio.addEventListener('change', () => {
      if (!radio.checked) return;
      setCaptionSourceMode(radio.value);
    });
  });

  mediaUrlInput?.addEventListener('input', () => {
    captionSourceState.mediaUrl = mediaUrlInput.value || '';
    persistState();
  });

  btnLoadCaptionSource?.addEventListener('click', () => loadCaptionSource());

  btnClearCaptionSource?.addEventListener('click', () => {
    captionSourceState.mediaUrl = '';
    mediaUrlInput.value = '';
    persistState();
    setStatus('Cleared caption source media URL.');
  });

  timelineRangeEl?.addEventListener('input', () => {
    stopTimelinePlayback();
    setTimelineTime(Number(timelineRangeEl.value) || 0);
  });

  btnTimelinePlay?.addEventListener('click', () => playTimelinePlayback());
  btnTimelinePause?.addEventListener('click', () => stopTimelinePlayback());
  btnTimelineReplay?.addEventListener('click', () => {
    stopTimelinePlayback();
    setTimelineTime(0);
    playTimelinePlayback();
  });

  applyOffsetEl?.addEventListener('change', () => {
    captionSourceState.applyOffset = !!applyOffsetEl.checked;
    persistState();
    renderTimelineFrame();
  });

  offsetMsInput?.addEventListener('input', () => {
    captionSourceState.offsetMs = Number(offsetMsInput.value) || 0;
    persistState();
    renderTimelineFrame();
  });

  offsetBackBtn?.addEventListener('click', () => {
    captionSourceState.offsetMs = (Number(captionSourceState.offsetMs) || 0) - 250;
    offsetMsInput.value = String(captionSourceState.offsetMs);
    persistState();
    renderTimelineFrame();
  });

  offsetForwardBtn?.addEventListener('click', () => {
    captionSourceState.offsetMs = (Number(captionSourceState.offsetMs) || 0) + 250;
    offsetMsInput.value = String(captionSourceState.offsetMs);
    persistState();
    renderTimelineFrame();
  });

  btnRenderVertical?.addEventListener('click', async () => {
    resetRenderStatus();
    const projectId = projectSelect?.value || '';
    const videoRel = videoSelect?.value || '';
    if (!projectId || !videoRel) {
      renderStatusEl.textContent = 'Select a project + video to render.';
      return;
    }

    renderStatusEl.textContent = 'Render job endpoint not configured.';
  });

  function populateFontPresets() {
    fontSelect.innerHTML = '';
    for (const p of FONT_PRESETS) {
      const opt = document.createElement('option');
      opt.value = p.id;
      opt.textContent = p.label;
      fontSelect.appendChild(opt);
    }
    fontSelect.value = cfg.fontId;
    fontUrlInput.value = cfg.fontUrl;
  }

  function populateTypographyProfiles() {
    typographyProfileSelect.innerHTML = '';
    for (const p of TYPOGRAPHY_PROFILE_OPTIONS) {
      const opt = document.createElement('option');
      opt.value = p.id;
      opt.textContent = p.label;
      typographyProfileSelect.appendChild(opt);
    }
    typographyProfileSelect.value = cfg.typographyProfile || DEFAULT_TYPOGRAPHY_PROFILE_ID;
  }

    function populateRevealStyles() {
      revealStyleSelect.innerHTML = '';
      for (const p of REVEAL_STYLE_OPTIONS) {
        const opt = document.createElement('option');
        opt.value = p.id;
        opt.textContent = p.label;
        revealStyleSelect.appendChild(opt);
      }
      revealStyleSelect.value = cfg.revealStyle;
    }

    function applyTextAlignSelection(value, { silent = false } = {}) {
      const align = (AnimationHelpers.normalizeTextAlign?.(value)) || 'center';
      cfg.textAlign = align;
      textAlignSelect.value = align;
      if (!silent) {
        setStatus('Line alignment: ' + align + '\n(Rebuild on Replay)');
      }
      persistState();
    }

    function populateThemes() {
      themeSelect.innerHTML = '';
      for (const t of THEME_OPTIONS) {
        const opt = document.createElement('option');
      opt.value = t.id;
      opt.textContent = t.label;
      themeSelect.appendChild(opt);
    }
    themeSelect.value = cfg.theme;
  }

  function applyTheme(themeId) {
    const chosen = THEME_OPTIONS.find(t => t.id === themeId) || THEME_OPTIONS[0];
    cfg.theme = chosen.id;
    cfg.backgroundColor = chosen.background;
    cfg.color = chosen.text;

    const bgColor = new THREE.Color(chosen.background);
    scene.background = bgColor.clone();
    renderer.setClearColor(bgColor, 1);
    document.body.style.background = `#${bgColor.getHexString()}`;

    lightingRig?.updatePalette?.({ text: cfg.color, background: cfg.backgroundColor });

    refreshAllMeshMaterials();
    persistState();
  }

  function applyFontPresetFromCfg() {
    const preset = FONT_PRESETS.find(p => p.id === cfg.fontId);
    fontSelect.value = cfg.fontId;
    if (preset?.url) {
      fontUrlInput.value = preset.url;
      cfg.fontUrl = preset.url;
    }
    if (preset?.format) {
      cfg.fontFormat = preset.format;
    }
  }

  function applyTypographyProfileSelection(profileId, { silent = false } = {}) {
    const applied = AnimationHelpers.applyTypographyProfile(cfg, profileId);
    Object.assign(cfg, applied.cfg);

    typographyProfileSelect.value = applied.profileId;
    applyFontPresetFromCfg();

    if (cfg.revealStyle) {
      revealStyleSelect.value = cfg.revealStyle;
    }
    if (!silent) {
      setStatus(`Applied typography profile: ${applied.profileId}\nRebuild on Replay to see spacing + depth changes.`);
    }
    persistState();
  }

  function populateEmphasisProfiles() {
    emphasisProfileSelect.innerHTML = '';
    for (const p of EMPHASIS_PROFILE_OPTIONS) {
      const opt = document.createElement('option');
      opt.value = p.id;
      opt.textContent = p.label;
      emphasisProfileSelect.appendChild(opt);
    }
    emphasisProfileSelect.value = cfg.emphasisProfile;
  }

  fontSelect.addEventListener('change', () => {
    const preset = FONT_PRESETS.find(p => p.id === fontSelect.value);
    cfg.fontId = fontSelect.value;
    if (preset && preset.url) fontUrlInput.value = preset.url;
    if (preset && preset.format) cfg.fontFormat = preset.format;
    cfg.fontUrl = fontUrlInput.value.trim() || cfg.fontUrl;
    cfg.typographyProfile = DEFAULT_TYPOGRAPHY_PROFILE_ID;
    typographyProfileSelect.value = cfg.typographyProfile;
    persistState();
  });

  fontUrlInput.addEventListener('input', () => {
    if (fontSelect.value === 'custom') {
      cfg.fontUrl = fontUrlInput.value.trim();
      cfg.typographyProfile = DEFAULT_TYPOGRAPHY_PROFILE_ID;
      typographyProfileSelect.value = cfg.typographyProfile;
      persistState();
    }
  });

  typographyProfileSelect.addEventListener('change', () => {
    applyTypographyProfileSelection(typographyProfileSelect.value);
  });

  revealStyleSelect.addEventListener('change', () => {
    cfg.revealStyle = revealStyleSelect.value;
    setStatus('Reveal style set to: ' + cfg.revealStyle + '\n(Rebuild on Replay)');
    persistState();
  });

  textAlignSelect.addEventListener('change', () => {
    applyTextAlignSelection(textAlignSelect.value);
  });

  themeSelect.addEventListener('change', async () => {
    applyTheme(themeSelect.value);
    setStatus('Theme set to: ' + cfg.theme + '\n(Rebuilding scene for new materials…)');
    try {
      await rebuildSceneFromCurrentSource();
      setStatus('Theme applied. Replaying with new background + text palette…');
      replay();
    } catch (err) {
      setStatus('Theme rebuild failed:\n' + String(err));
    }
  });

  emphasisProfileSelect.addEventListener('change', () => {
    cfg.emphasisProfile = emphasisProfileSelect.value;
    setStatus('Emphasis profile: ' + cfg.emphasisProfile + '\n(Semantic + terminal rules stacked)');
    persistState();
  });

  cfgDetails.addEventListener('toggle', () => {
    cfgPill.textContent = cfgDetails.open ? 'expanded' : 'collapsed';
  });

  // -------------------------
  // Persistence
  // -------------------------
  function readLocalState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      return normalizePersistedPayload(raw);
    } catch (_) {
      return null;
    }
  }

  async function fetchSeedState() {
    for (const url of STORAGE_SEED_URLS) {
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) continue;
        const data = await res.json();
        const payload = normalizePersistedPayload(data);
        if (payload && typeof payload === 'object') return payload;
      } catch (_) { /* ignore */ }
    }
    return null;
  }

  function persistState() {
    try {
      const payload = {
        cfg: sanitizePersistedState(DEFAULT_CFG, cfg),
        wpl: Number(wplEl?.value ?? 0) || 0,
        workspace: {
          project: workspaceState.project || '',
          video: workspaceState.video || '',
        },
        captionSource: {
          mode: captionSourceState.mode,
          mediaUrl: captionSourceState.mediaUrl,
          applyOffset: !!captionSourceState.applyOffset,
          offsetMs: Number(captionSourceState.offsetMs) || 0,
        },
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
    } catch (_) {}
  }

  function applyPersistedState(payload) {
    if (!payload || typeof payload !== 'object') return;
      const cfgPatch = sanitizePersistedState(DEFAULT_CFG, payload.cfg || payload);
      if (cfgPatch.revealStyle === 'rise') cfgPatch.revealStyle = 'slide-up';
      Object.assign(cfg, cfgPatch);
      cfg.textAlign = (AnimationHelpers.normalizeTextAlign?.(cfg.textAlign)) || 'center';

      const validRevealIds = new Set(REVEAL_STYLE_OPTIONS.map(o => o.id));
      if (!validRevealIds.has(cfg.revealStyle)) cfg.revealStyle = 'slide-up';

    if (payload.workspace && typeof payload.workspace === 'object') {
      if (typeof payload.workspace.project === 'string') workspaceState.project = payload.workspace.project;
      if (typeof payload.workspace.video === 'string') workspaceState.video = payload.workspace.video;
    }

    if (payload.captionSource && typeof payload.captionSource === 'object') {
      captionSourceState = {
        ...captionSourceState,
        mode: payload.captionSource.mode || captionSourceState.mode,
        mediaUrl: payload.captionSource.mediaUrl || captionSourceState.mediaUrl,
        applyOffset: payload.captionSource.applyOffset !== undefined ? !!payload.captionSource.applyOffset : captionSourceState.applyOffset,
        offsetMs: Number(payload.captionSource.offsetMs) || 0,
      };
    }

    if (typeof payload.wpl === 'number' && isFinite(payload.wpl)) {
      wplEl.value = String(payload.wpl);
      wplValEl.textContent = String(payload.wpl);
    } else {
      wplValEl.textContent = String(wplEl.value);
    }

    ohEl.value = String(cfg.endOverhangFactor);
    ohValEl.textContent = Number(cfg.endOverhangFactor).toFixed(2);
      keepPrevEl.checked = !!cfg.keepPreviousLinesVisible;
      fontSelect.value = cfg.fontId;
      fontUrlInput.value = cfg.fontUrl;
      revealStyleSelect.value = cfg.revealStyle;
      textAlignSelect.value = cfg.textAlign;
      themeSelect.value = cfg.theme;
      typographyProfileSelect.value = cfg.typographyProfile || DEFAULT_TYPOGRAPHY_PROFILE_ID;
      emphasisProfileSelect.value = cfg.emphasisProfile;

      applyTypographyProfileSelection(cfg.typographyProfile || DEFAULT_TYPOGRAPHY_PROFILE_ID, { silent: true });
      applyTextAlignSelection(cfg.textAlign, { silent: true });
      applyTheme(cfg.theme);
      syncWorkspaceInputs();

      setCaptionSourceMode(captionSourceState.mode);
      mediaUrlInput.value = captionSourceState.mediaUrl || '';
      applyOffsetEl.checked = !!captionSourceState.applyOffset;
      offsetMsInput.value = String(captionSourceState.offsetMs || 0);
      updateTimelineDisplay();
    }

  async function hydrateState() {
    const stored = readLocalState();
    if (stored) { applyPersistedState(stored); return; }
    const seeded = await fetchSeedState();
    if (seeded) {
      applyPersistedState(seeded);
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(seeded)); } catch (_) {}
    }
  }

  function setWorkspaceStatus(msg) {
    if (workspaceStatusEl) workspaceStatusEl.textContent = msg;
  }

  function syncWorkspaceInputs() {
    if (projectSelect) projectSelect.value = workspaceState.project || '';
    if (videoSelect) videoSelect.value = workspaceState.video || '';
  }

  async function refreshProjects({ keepSelection = true } = {}) {
    if (!projectSelect) return;
    setWorkspaceStatus('Loading projects…');
    projectSelect.innerHTML = '<option value="">Select a project</option>';
    try {
      const res = await fetch('/api/projects', { cache: 'no-store' });
      if (!res.ok) throw new Error('request failed');
      const data = await res.json();
      const items = Array.isArray(data.projects) ? data.projects : [];
      for (const name of items) {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        projectSelect.appendChild(opt);
      }
      if (keepSelection && workspaceState.project && items.includes(workspaceState.project)) {
        projectSelect.value = workspaceState.project;
        await refreshVideos(workspaceState.project, { keepSelection: true });
      } else {
        workspaceState.project = projectSelect.value || '';
        workspaceState.video = '';
        syncWorkspaceInputs();
        persistState();
      }
      setWorkspaceStatus('Projects ready.');
    } catch (err) {
      setWorkspaceStatus('Project listing failed.');
    }
  }

  async function refreshVideos(projectId, { keepSelection = false } = {}) {
    if (!videoSelect) return;
    if (!projectId) {
      videoSelect.innerHTML = '<option value="">Select a project</option>';
      return;
    }
    setWorkspaceStatus('Loading media…');
    videoSelect.innerHTML = '<option value="">Select a video</option>';
    try {
      const res = await fetch(`/api/projects/${encodeURIComponent(projectId)}/media`, { cache: 'no-store' });
      if (!res.ok) throw new Error('request failed');
      const data = await res.json();
      const items = Array.isArray(data.videos) ? data.videos : [];
      for (const rel of items) {
        const opt = document.createElement('option');
        opt.value = rel;
        opt.textContent = rel;
        videoSelect.appendChild(opt);
      }
      if (keepSelection && workspaceState.video && items.includes(workspaceState.video)) {
        videoSelect.value = workspaceState.video;
      } else {
        workspaceState.video = videoSelect.value || '';
        syncWorkspaceInputs();
        persistState();
      }
      setWorkspaceStatus('Media ready.');
    } catch (err) {
      setWorkspaceStatus('Media listing failed.');
    }
  }

  async function generateWorkspaceCaptions() {
    const projectId = projectSelect?.value || '';
    const videoRel = videoSelect?.value || '';
    if (!projectId || !videoRel) {
      setWorkspaceStatus('Select a project + video first.');
      return;
    }

    setWorkspaceStatus('Generating captions…');
    try {
      const res = await fetch(`/api/projects/${encodeURIComponent(projectId)}/media/generate-captions`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ video_rel_path: videoRel, model_size: 'small', max_chars: Number(wplEl.value) * 4 }),
      });
      if (!res.ok) {
        const txt = await res.text();
        setWorkspaceStatus(`Generate failed: ${txt || res.status}`);
        return;
      }
      const data = await res.json();
      const linesUrl = `/api/projects/${encodeURIComponent(projectId)}/file?path=${encodeURIComponent(data.lines_rel_path)}`;
      cfg.linesUrl = linesUrl;
      workspaceState.project = projectId;
      workspaceState.video = videoRel;
      transcriptionData = null;
      setCaptionSourceMode('lines');
      persistState();

      const lines = await loadLines(cfg.linesUrl);
      if (!fontRef) fontRef = await loadFontFromSelection();
      buildFromPlainLines(fontRef, lines);
      setStatus(`Generated captions for ${videoRel}\nLines: ${lines.length}`);
      setWorkspaceStatus('Captions ready.');
      replay();
    } catch (err) {
      setWorkspaceStatus('Generate failed.');
    }
  }

  function setCaptionSourceMode(mode) {
    captionSourceState.mode = mode;
    captionSourceRadios.forEach(radio => {
      radio.checked = radio.value === mode;
    });
    const needsMedia = mode === 'srt' || mode === 'cues';
    mediaUrlInput.disabled = !needsMedia;
    btnLoadCaptionSource.disabled = false;
    if (!needsMedia) {
      stopTimelinePlayback();
      timelineLines = [];
      timelineLineSource = [];
      timelineState.durationMs = 0;
      setTimelineTime(0, { silent: true });
      setActiveCaptionPreview('');
      updateTimelineDisplay();
    }
    persistState();
  }

  function updateTimelineDisplay() {
    timelineTimecodeEl.textContent = formatTimecode(timelineState.currentMs);
    timelineDurationEl.textContent = `/ ${formatTimecode(timelineState.durationMs)}`;
    const max = Math.max(1, Math.floor(timelineState.durationMs));
    timelineRangeEl.max = String(max);
    timelineRangeEl.value = String(Math.min(max, Math.floor(timelineState.currentMs)));
  }

  function setTimelineTime(ms, { silent = false } = {}) {
    timelineState.currentMs = Math.max(0, Math.min(timelineState.durationMs, Number(ms) || 0));
    updateTimelineDisplay();
    if (!silent && timelineLines.length) {
      renderTimelineFrame();
    }
  }

  function getEffectiveOffsetMs() {
    return captionSourceState.applyOffset ? (Number(captionSourceState.offsetMs) || 0) : 0;
  }

  function setActiveCaptionPreview(text) {
    activeCaptionPreview.textContent = text || 'Active caption will appear here.';
  }

  function stopTimelinePlayback() {
    timelineState.isPlaying = false;
    if (timelineRafId) {
      cancelAnimationFrame(timelineRafId);
      timelineRafId = null;
    }
    timelineLastTick = null;
    if (typeof timelineStopCallback === 'function') {
      const cb = timelineStopCallback;
      timelineStopCallback = null;
      cb();
    }
  }

  function playTimelinePlayback({ onStop } = {}) {
    if (!timelineLines.length) {
      setStatus('No timeline captions loaded.');
      return;
    }
    if (timelineState.isPlaying) return;
    timelineState.isPlaying = true;
    timelineLastTick = performance.now();
    if (onStop) timelineStopCallback = onStop;

    const tick = (now) => {
      if (!timelineState.isPlaying) return;
      const dt = Math.max(0, now - (timelineLastTick || now));
      timelineLastTick = now;
      setTimelineTime(timelineState.currentMs + dt, { silent: true });
      renderTimelineFrame(now);
      if (timelineState.currentMs >= timelineState.durationMs) {
        stopTimelinePlayback();
        return;
      }
      timelineRafId = requestAnimationFrame(tick);
    };

    timelineRafId = requestAnimationFrame(tick);
  }

  function clearTimelineScene() {
    clearAllLinesFromScene();
    timelineState.activeIndex = -1;
    render();
  }

  function prepareTimelineFromLineObjs(lines) {
    let cursorMs = 0;
    for (const line of lines) {
      const hasTiming = typeof line.startTime === 'number' && typeof line.endTime === 'number';
      if (!hasTiming) {
        const pauseMs = Math.max(0, line.pauseMs || 0);
        const holdMs = Math.max(0, line.holdMs || 0);
        cursorMs += pauseMs;
        const durationMs = Math.max(50, line.durationMs || 0);
        line.startTime = cursorMs / 1000;
        cursorMs += durationMs;
        line.endTime = cursorMs / 1000;
        cursorMs += holdMs + (cfg.lineHoldMsAfterComplete || 0);
      } else {
        const endMs = (Number(line.endTime) || 0) * 1000;
        cursorMs = Math.max(cursorMs, endMs + (cfg.lineHoldMsAfterComplete || 0));
      }
    }
    timelineLines = lines;
    timelineState.durationMs = Math.max(0, cursorMs);
    updateTimelineDisplay();
  }

  function getActiveTimelineIndex(timeSec, lines) {
    for (let i = 0; i < lines.length; i++) {
      if (timeSec >= lines[i].startTime && timeSec <= lines[i].endTime) return i;
    }
    return -1;
  }

  function resetLineRevealState(lineObj) {
    if (!lineObj?.meshes) return;
    lineObj.cameraState = null;
    lineObj.lastRenderAt = null;
    for (const mesh of lineObj.meshes) {
      mesh.visible = false;
      mesh.material.opacity = 0;
      mesh.userData.revealStart = null;
      mesh.userData.revealed = false;
      mesh.scale.setScalar(1);
      mesh.position.copy(mesh.userData.basePos);
    }
  }

  function ensureActiveTimelineLine(index) {
    if (index === timelineState.activeIndex) return;
    clearAllLinesFromScene();
    timelineState.activeIndex = index;
    if (index < 0) return;
    const lineObj = timelineLines[index];
    if (!lineObj) return;
    lineObj.group.position.y = 0;
    resetLineRevealState(lineObj);
    scene.add(lineObj.group);
  }

  function renderLineAtTime(lineObj, currentTimeSec, now) {
    if (!lineObj) return;
    const { meshes, centers, widths, words, startTime, endTime, group, emphasisFlags } = lineObj;
    const n = centers.length;
    if (n === 0) return;

    const emphasisProfile = getEmphasisProfile();
    const lineProfile = lineObj.profileSettings || getLineProfile(lineObj.profileId);
    const activeRevealStyle = lineObj.revealStyleOverride || lineProfile?.revealStyle || cfg.revealStyle;
    for (const m of meshes) m.userData.revealStyle = activeRevealStyle;

    const durationSec = Math.max(0.05, (endTime - startTime));
    const uRaw = clamp01((currentTimeSec - startTime) / durationSec);
    const eased = smooth01(uRaw);
    const u = easeOutEndU(eased);

    const c2 = centersWithGroupY(centers, group.position.y);
    const curve = new THREE.CatmullRomCurve3(c2, false, 'catmullrom', 0.5);
    const bounds = computeCenterBounds(c2);
    const ARC_SAMPLES = Math.max(320, n * 120);
    const lengths = curve.getLengths(ARC_SAMPLES);
    const totalLen = lengths[lengths.length - 1];

    const dist = u * totalLen;
    let idx = 0;
    while (idx < lengths.length && lengths[idx] < dist) idx++;
    const denom = Math.max(1, lengths.length - 1);
    const t = idx / denom;
    const activeIdx = computeActiveWordIndex(Array.isArray(words) && words.length === meshes.length ? words : null, currentTimeSec, uRaw, n);
    const activeProgress = (typeof activeIdx === 'number' && activeIdx >= 0)
      ? clamp01(activeIdx / Math.max(1, n - 1))
      : 0;
    const adjustedLookAhead = Math.max(0, cfg.curveLookAheadU + (lineProfile?.lookAheadOffset ?? 0)) * (0.32 + 0.28 * activeProgress);
    const t2 = Math.min(1, t + adjustedLookAhead);
    const isEmphasis = activeIdx >= 0 && Array.isArray(emphasisFlags) && emphasisFlags[activeIdx];
    const isTerminal = activeIdx === (n - 1);
    const bias = computeEmphasisBias(emphasisProfile, activeIdx, emphasisFlags, widths, uRaw) + (lineProfile?.endBiasPx ?? 0);

    let target = curve.getPointAt(t2);
    const focus = (activeIdx >= 0 && activeIdx < c2.length) ? c2[activeIdx] : null;
    if (focus) {
      const blend = Math.min(0.72, 0.28 + (isEmphasis ? 0.10 : 0) + (isTerminal ? 0.12 : 0));
      target.lerp(focus, blend);
    }
    target = shapeTargetWithBounds(target, uRaw, c2, widths, bounds, bias);

    const dt = Math.max(0.001, ((now || performance.now()) - (lineObj.lastRenderAt || performance.now())) / 1000);
    lineObj.lastRenderAt = now || performance.now();

    const followLambda = cfg.followLambda * (lineProfile?.followMult ?? 1);
    const lookLambda = cfg.lookAtLambda * (lineProfile?.lookAtMult ?? 1);
    const baseCamDistance = cfg.cameraDistance + (lineProfile?.cameraDistanceOffset ?? 0);
    if (!lineObj.cameraState) {
      lineObj.cameraState = {
        camX: camera.position.x,
        camY: camera.position.y,
        lookAtX: camera.position.x,
        lookAtY: camera.position.y,
        camDistance: baseCamDistance,
        targetX: camera.position.x,
        targetY: camera.position.y,
      };
    }
    const state = lineObj.cameraState;
    const targetLambda = Math.max(0.1, followLambda * 1.05);
    state.targetX = damp(state.targetX, target.x, targetLambda, dt);
    state.targetY = damp(state.targetY, target.y, targetLambda, dt);

    if (Array.isArray(words) && words.length === meshes.length) {
      for (let k = 0; k < words.length; k++) {
        if (currentTimeSec >= Number(words[k].startTime ?? 0)) startReveal(meshes[k], now || performance.now());
      }
    } else {
      const p = uRaw * (n - 1);
      const revealIdx = Math.min(n - 1, Math.floor(p + cfg.revealWordLead));
      for (let k = 0; k <= revealIdx; k++) startReveal(meshes[k], now || performance.now());
    }

    for (const m of meshes) tickReveal(m, now || performance.now());

    updateActiveHighlight(meshes, activeIdx, emphasisProfile, dt);

    const followScale = (isEmphasis ? (emphasisProfile?.emphasisFollowMult ?? 1) : 1) * (isTerminal ? (emphasisProfile?.terminalFollowMult ?? 1) : 1);
    const lookScale = (isEmphasis ? (emphasisProfile?.emphasisLookAtMult ?? 1) : 1) * (isTerminal ? (emphasisProfile?.terminalLookAtMult ?? 1) : 1);

    const camLambda = Math.max(0.08, followLambda * followScale * 0.9);
    state.camX = damp(state.camX, state.targetX, camLambda, dt);
    state.camY = damp(state.camY, state.targetY, camLambda, dt);

    const desiredDistance = frameCameraDistance(baseCamDistance, activeIdx, widths, bounds);
    state.camDistance = damp(state.camDistance, desiredDistance, Math.max(2.5, followLambda * 0.55), dt);

    const lookTargetLambda = Math.max(0.08, lookLambda * lookScale * 0.9);
    state.lookAtX = damp(state.lookAtX, state.targetX, lookTargetLambda, dt);
    state.lookAtY = damp(state.lookAtY, state.targetY, lookTargetLambda, dt);

    camera.position.set(state.camX, state.camY, state.camDistance);
    camera.lookAt(state.lookAtX, state.lookAtY, target.z);
    renderer.render(scene, camera);
  }

  function renderTimelineFrame(now) {
    if (!timelineLines.length) {
      clearTimelineScene();
      setActiveCaptionPreview('');
      return;
    }
    const offsetMs = getEffectiveOffsetMs();
    const currentSec = (timelineState.currentMs + offsetMs) / 1000;
    const activeIndex = getActiveTimelineIndex(currentSec, timelineLines);
    ensureActiveTimelineLine(activeIndex);
    if (activeIndex < 0) {
      setActiveCaptionPreview('');
      render();
      return;
    }
    const activeLine = timelineLines[activeIndex];
    setActiveCaptionPreview(activeLine?.text || '');
    renderLineAtTime(activeLine, currentSec, now);
  }

  function resetRenderStatus() {
    renderProgressEl.style.width = '0%';
    renderStatusEl.textContent = 'Server render job idle.';
    renderDownloadEl.textContent = '';
    renderDownloadEl.href = '';
  }

  async function loadCaptionSource() {
    const mode = captionSourceState.mode;
    const mediaUrl = captionSourceState.mediaUrl.trim();
    if (mode === 'lines') {
      transcriptionData = null;
      timelineLines = [];
      timelineLineSource = [];
      timelineState.durationMs = 0;
      setTimelineTime(0, { silent: true });
      await replay();
      return;
    }

    if (!mediaUrl) {
      setStatus('Enter a media URL for SRT/Cues mode.');
      return;
    }

    transcriptionData = null;

    setStatus(`Loading ${mode.toUpperCase()} captions…`);
    try {
      let cues = [];
      if (mode === 'cues') {
        const res = await fetch(`/api/captions/cues?media_url=${encodeURIComponent(mediaUrl)}`, { cache: 'no-store' });
        if (!res.ok) throw new Error(`Cues fetch failed: ${res.status}`);
        const payload = await res.json();
        cues = Array.isArray(payload.cues) ? payload.cues : [];
      } else {
        const res = await fetch(`/api/captions/srt?media_url=${encodeURIComponent(mediaUrl)}`, { cache: 'no-store' });
        if (!res.ok) throw new Error(`SRT fetch failed: ${res.status}`);
        const srtText = await res.text();
        cues = AnimationHelpers.parseSrtCues?.(srtText) || [];
      }

      const normalized = cues.map((cue) => {
        const startMs = Number(cue.startMs ?? 0);
        const endMs = Number(cue.endMs ?? startMs);
        const words = AnimationHelpers.buildCueWordTimings?.(cue.text || '', startMs, endMs) || [];
        return {
          text: String(cue.text || '').trim(),
          startTime: startMs / 1000,
          endTime: endMs / 1000,
          words,
        };
      }).filter(item => item.text);

      if (!normalized.length) {
        setStatus('No cues found for this media URL.');
        return;
      }

      if (!fontRef) fontRef = await loadFontFromSelection();
      buildFromTimedLines(fontRef, normalized);
      timelineLineSource = normalized;
      timelineLines = lineObjs;
      timelineState.durationMs = Math.max(0, Math.max(...normalized.map(item => item.endTime * 1000)));
      setTimelineTime(0, { silent: true });
      clearAllLinesFromScene();
      setStatus(`Loaded ${normalized.length} cues from ${mode.toUpperCase()} source.`);
      renderTimelineFrame();
    } catch (err) {
      setStatus(`Caption source load failed:\n${String(err)}`);
    }
  }

  // -------------------------
  // Helpers
  // -------------------------
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function smooth01(t){ t = clamp01(t); return t * t * (3 - 2 * t); }
  function easeOutCubic(t){ t = clamp01(t); return 1 - Math.pow(1 - t, 3); }
  function easeOutBack(t, overshoot = 0.30){
    t = clamp01(t);
    const c1 = 1.70158 + overshoot * 2.0;
    const c3 = c1 + 1;
    return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
  }
  function damp(current, target, lambda, dt) {
    return current + (target - current) * (1 - Math.exp(-lambda * dt));
  }
  function getEmphasisProfile() {
    return EMPHASIS_PROFILES[cfg.emphasisProfile] || EMPHASIS_PROFILES.documentary || EMPHASIS_PROFILES[EMPHASIS_PROFILE_OPTIONS[0]?.id];
  }
  function parseEmphasisToken(wordText = '') {
    const isEmphasized = /\*\*(.+?)\*\*/.test(wordText);
    const cleanText = String(wordText).replace(/\*\*/g, '') || String(wordText || '').trim();
    return { cleanText, isEmphasized };
  }
  const sanitizePersistedState = (window.AnimationHelpers && typeof window.AnimationHelpers.sanitizePersistedState === 'function')
    ? window.AnimationHelpers.sanitizePersistedState
    : function fallbackSanitize(defaults = {}, stored = {}) {
        const base = (defaults && typeof defaults === 'object') ? defaults : {};
        const src = (stored && typeof stored === 'object') ? stored : {};
        const out = {};
        for (const [key, defVal] of Object.entries(base)) {
          if (!(key in src)) continue;
          const val = src[key];
          if (typeof defVal === 'number') {
            const num = Number(val);
            if (isFinite(num)) out[key] = num;
          } else if (typeof defVal === 'boolean') {
            if (typeof val === 'boolean') out[key] = val;
            else if (typeof val === 'string') out[key] = val.toLowerCase() === 'true';
            else if (typeof val === 'number') out[key] = !!val;
          } else if (typeof defVal === 'string') {
            if (val !== undefined && val !== null) out[key] = String(val);
          }
        }
      return out;
    };
  const normalizePersistedPayload = (window.AnimationHelpers && typeof window.AnimationHelpers.normalizePersistedPayload === 'function')
    ? window.AnimationHelpers.normalizePersistedPayload
    : function fallbackNormalize(raw) {
        if (raw == null) return null;
        if (typeof raw === 'string') {
          try { return fallbackNormalize(JSON.parse(raw)); } catch (_) { return null; }
        }
        if (typeof raw !== 'object') return null;
        if (raw.captioner_state_v1) {
          const inner = fallbackNormalize(raw.captioner_state_v1);
          if (inner) return inner;
        }
        return raw;
      };
  function emphasisScaleFor(mesh, elapsedMs, profile) {
    if (!mesh?.userData?.emphasis || !profile) return 1;
    const settleMs = Math.max(0, profile.emphasisSettleMs ?? 0);
    const window = cfg.revealMs + settleMs;
    const t = window > 0 ? clamp01(elapsedMs / window) : 1;
    const e = smooth01(t);
    return 1 + (profile.emphasisScale - 1) * e;
  }
  function computeActiveWordIndex(words, currentTimeSec, uRaw, fallbackCount) {
    if (Array.isArray(words) && words.length) {
      let idx = -1;
      for (let i = 0; i < words.length; i++) {
        const start = Number(words[i].startTime ?? -Infinity);
        if (currentTimeSec >= start) idx = i; else break;
      }
      if (idx >= 0) return Math.min(idx, words.length - 1);
    }
    if (typeof fallbackCount === 'number' && fallbackCount > 0) {
      return Math.min(fallbackCount - 1, Math.floor(uRaw * (fallbackCount - 1)));
    }
    return -1;
  }
  function computeEmphasisBias(profile, activeIdx, emphasisFlags, widths, uRaw) {
    if (!profile || activeIdx < 0 || !widths?.length) return 0;
    const activeWidth = widths[activeIdx] || 0;
    const isEmphasis = Array.isArray(emphasisFlags) ? !!emphasisFlags[activeIdx] : false;
    let bias = 0;
    if (isEmphasis) bias += activeWidth * (profile.emphasisDriftFrac ?? 0);
    if (activeIdx === widths.length - 1) {
      const settle = smooth01(uRaw);
      bias += activeWidth * (profile.terminalDriftFrac ?? 0) * settle;
    }
    return bias;
  }

  function formatTimecode(ms) {
    const safe = Math.max(0, Number(ms) || 0);
    const totalSeconds = Math.floor(safe / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const millis = Math.floor(safe % 1000);
    return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(millis).padStart(3, '0')}`;
  }

  const parseScriptLines = (window.AnimationHelpers && typeof window.AnimationHelpers.parseScriptLines === 'function')
    ? window.AnimationHelpers.parseScriptLines
    : function fallbackParse(lines = [], defaultProfileId = DEFAULT_LINE_PROFILE_ID) {
        const normalize = (token = '') => {
          const trimmed = String(token || '').trim();
          if (!trimmed) return DEFAULT_LINE_PROFILE_ID;
          return trimmed.length === 1 ? trimmed.toUpperCase() : trimmed.toLowerCase();
        };

        const segments = [];
        let active = normalize(defaultProfileId);
        let pendingPause = 0;
        let pendingHold = 0;
        let pendingBreaks = 0;

        for (const raw of lines || []) {
          const line = String(raw ?? '').trim();
          if (!line) continue;

          let content = line;
          const directive = content.match(/^#([A-Za-z0-9_-]+)(?:\s+(.+))?$/);
          if (directive) {
            active = normalize(directive[1]);
            content = (directive[2] || '').trim();
          }

          let pauseMs = 0;
          let holdMs = 0;
          let breaks = 0;
          content = content.replace(/\[PAUSE\s*=\s*(\d+)\]/gi, (_, ms) => { pauseMs += Number(ms) || 0; return ' '; });
          content = content.replace(/\[HOLD\s*=\s*(\d+)\]/gi, (_, ms) => { holdMs += Number(ms) || 0; return ' '; });
          content = content.replace(/\[(BREAK|BR)(?:\s*=\s*(\d+))?\]/gi, (_, __, count) => {
            const n = Number(count);
            breaks += isFinite(n) && n > 0 ? Math.floor(n) : 1;
            return ' ';
          });

          const text = content.trim();
          pendingBreaks += breaks;
          if (!text) {
            pendingPause += pauseMs;
            pendingHold += holdMs;
            continue;
          }

          segments.push({
            profileId: active,
            text,
            pauseMs: pendingPause + pauseMs,
            holdMs: pendingHold + holdMs,
            breaks: pendingBreaks,
          });

          pendingPause = 0;
          pendingHold = 0;
          pendingBreaks = 0;
        }

        return segments;
      };

  function getLineProfile(profileId = DEFAULT_LINE_PROFILE_ID) {
    return LINE_PROFILE_PRESETS[profileId] || LINE_PROFILE_PRESETS[DEFAULT_LINE_PROFILE_ID];
  }

  function estimateSegmentDurationMs(wordCount, punctuationCount, profileSettings) {
    const pace = Math.max(0.01, profileSettings?.speedMultiplier ?? 1);
    const wordsPerSec = Math.max(0.1, cfg.wordsPerSecond * pace);
    const baseMs = wordCount > 0 ? (wordCount / wordsPerSec) * 1000 : 0;
    const punctuationMs = Math.max(0, (punctuationCount || 0) * 90);
    return Math.max(300, baseMs + punctuationMs);
  }
  function render() { renderer.render(scene, camera); }

  const fontLoader = new THREE.FontLoader();
  const ttfLoader = new THREE.TTFLoader();
  fontLoader.setCrossOrigin?.('anonymous');
  ttfLoader.setCrossOrigin?.('anonymous');
  const FALLBACK_CANVAS_FONT = { isCanvasFont: true };

  function guessFontFormat(url, fmt = 'auto') {
    if (fmt && fmt !== 'auto') return fmt;
    if (!url) return 'typeface';
    const lower = url.toLowerCase();
    if (lower.endsWith('.ttf') || lower.endsWith('.otf')) return 'ttf';
    return 'typeface';
  }

  function resolveFontPreset(fontId, fallbackUrl) {
    const preset = FONT_PRESETS.find(p => p.id === fontId) || FONT_PRESETS[0];
    const url = preset.url || fallbackUrl || DEFAULT_CFG.fontUrl;
    const format = guessFontFormat(url, preset.format || cfg.fontFormat);
    return { preset, url, format };
  }

  function loadFontResource(url, format) {
    return new Promise((resolve, reject) => {
      const fmt = guessFontFormat(url, format);
      const onError = (err) => reject(err || new Error('font load failed'));
      if (fmt === 'ttf') {
        ttfLoader.load(url, (json) => {
          try {
            const f = new THREE.Font(json);
            const normalized = AnimationHelpers.normalizeFontResource?.(f) || f;
            resolve(normalized);
          } catch (e) {
            reject(e);
          }
        }, undefined, onError);
      } else {
        fontLoader.load(url, (font) => {
          const normalized = AnimationHelpers.normalizeFontResource?.(font) || font;
          resolve(normalized);
        }, undefined, onError);
      }
    });
  }

  async function loadLines(url) {
    try {
      const res = await fetch(url, { cache: 'no-store' });
      if(!res.ok) throw new Error(`Failed to load lines: ${res.status} ${res.statusText}`);
      const txt = await res.text();
      const parsed = txt.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
      if (parsed.length === 0) throw new Error('lines file was empty');
      return parsed;
    } catch (err) {
      console.warn('loadLines fallback to built-in demo:', err);
      return [...FALLBACK_DEMO_LINES];
    }
  }

  async function loadFontFromSelection(forceUrl) {
    const { preset, url, format } = resolveFontPreset(cfg.fontId, cfg.fontUrl);
    const candidateUrl = forceUrl || (cfg.fontId === 'custom' ? (fontUrlInput.value.trim() || url) : url);
    const fmt = guessFontFormat(candidateUrl, format);
    cfg.fontUrl = candidateUrl;
    cfg.fontFormat = fmt;

    try {
      const font = await loadFontResource(candidateUrl, fmt);
      const isValid = AnimationHelpers.isValidFontResource(font);
      if (!isValid) throw new Error('font resource missing glyph data/resolution');
      fontRef = font;
      setStatus(`Loaded font: ${preset?.label ?? cfg.fontId}\nFormat: ${fmt}`);
      return font;
    } catch (err) {
      console.warn('font load failed, using canvas fallback', err);
      fontRef = FALLBACK_CANVAS_FONT;
      setStatus(`Font load failed; using canvas fallback.
${String(err)}`);
      return fontRef;
    }
  }

  async function loadTranscriptionFromResolve() {
    try {
      const res = await fetch('/api/get-transcription', { cache: 'no-store' });
      const data = await res.json();
      if (data && data.error) return { error: data.error, instructions: data.instructions };
      return data;
    } catch (e) {
      return { error: String(e) };
    }
  }

  function getSpaceAdvance(font) {
    if (AnimationHelpers.isValidFontResource(font) && font?.data?.glyphs) {
      const glyph = font.data.glyphs[' '] ?? null;
      const ha = (glyph && typeof glyph.ha === 'number') ? glyph.ha : 20;
      const scale = cfg.textSize / (font.data?.resolution || 1000);
      return ha * scale;
    }
    return cfg.textSize * 0.55;
  }

  function createCanvasWordMesh(text, emphasis = false) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const pxSize = 128;
    const fontWeight = emphasis ? '800' : '700';
    ctx.font = `${fontWeight} ${pxSize}px system-ui, -apple-system, sans-serif`;
    const metrics = ctx.measureText(text);
    const pad = pxSize * 0.3;
    const width = Math.max(4, Math.ceil(metrics.width + pad * 2));
    const height = Math.ceil(pxSize * 1.35);
    canvas.width = width;
    canvas.height = height;
    ctx.font = `${fontWeight} ${pxSize}px system-ui, -apple-system, sans-serif`;
    ctx.fillStyle = new THREE.Color(cfg.color).getStyle();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, width / 2, height / 2 + pxSize * 0.08);

    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    texture.minFilter = THREE.LinearFilter;

    const mat = new THREE.MeshBasicMaterial({ map: texture, transparent: true, alphaTest: 0.01 });
    const geom = new THREE.PlaneGeometry(width, height);
    const mesh = new THREE.Mesh(geom, mat);

    const scale = cfg.textSize / height;
    mesh.scale.setScalar(scale);

    return { mesh, worldWidth: width * scale };
  }

  function buildLine(font, lineText, wordMeta) {
    const group = new THREE.Group();
    const hasValidFont = AnimationHelpers.isValidFontResource(font);
    const isCanvasFont = !!font?.isCanvasFont || !hasValidFont;
    const spaceW = getSpaceAdvance(font) * cfg.spaceMultiplier;
    const layoutScale = Math.max(1, cfg.revealPopScale || 1, (getEmphasisProfile()?.emphasisScale || 1));

    const source = Array.isArray(wordMeta) && wordMeta.length
      ? wordMeta.map(w => ({ ...w, text: String(w?.text ?? '').trim() }))
      : lineText.split(/\s+/).map(w => ({ text: w }));

    const emphasisFlags = [];
    const normalizedWords = [];
    const parsedWords = source.map((entry) => {
      const { cleanText, isEmphasized } = parseEmphasisToken(entry.text);
      if (!cleanText) return null;
      emphasisFlags.push(isEmphasized);
      normalizedWords.push({ ...entry, text: cleanText, emphasis: isEmphasized });
      if (isCanvasFont) {
        const canvasWord = createCanvasWordMesh(cleanText, isEmphasized);
        return { meshOverride: canvasWord.mesh, width: canvasWord.worldWidth * layoutScale, textLen: cleanText.length };
      }

      const geomSpec = AnimationHelpers.buildTextGeometrySpec(cfg.textSize, cfg.textDepth);
      const geom = new THREE.TextGeometry(cleanText, { font, ...geomSpec });
      geom.computeBoundingBox();
      const bb = geom.boundingBox;

      const width = (bb.max.x - bb.min.x) * layoutScale;
      geom.translate(-bb.min.x, 0, 0);
      return { geom, width, textLen: cleanText.length };
    }).filter(Boolean);

      const totalW =
        parsedWords.reduce((s,d)=>s+d.width,0) +
        (parsedWords.length - 1) * spaceW * layoutScale;

      const textAlign = (AnimationHelpers.normalizeTextAlign?.(cfg.textAlign)) || 'center';
      let cursorX = (AnimationHelpers.lineAlignmentOffset?.(totalW, textAlign)) ?? (-totalW / 2);

    const meshes  = [];
    const centers = [];
    const widths  = [];

    for (let i = 0; i < parsedWords.length; i++) {
      const d = parsedWords[i];

      const mat = baseMat.clone();
      mat.opacity = 0;
      if (!d.meshOverride) applyMaterialTone(mat, !!emphasisFlags[i]);

      const mesh = d.meshOverride || new THREE.Mesh(d.geom, mat);
      if (!d.meshOverride) mesh.material = mat; else mesh.material.opacity = 0;
      mesh.position.set(cursorX, 0, 0);
      mesh.visible = false;

      mesh.userData.revealStart = null;
      mesh.userData.revealed = false;
      mesh.userData.basePos = mesh.position.clone();
      mesh.userData.wordLength = d.textLen || 0;
      mesh.userData.emphasis = !!emphasisFlags[i];
      mesh.userData.isLast = (i === parsedWords.length - 1);
      mesh.userData.activeWeight = 0;

      group.add(mesh);
      meshes.push(mesh);

      centers.push(new THREE.Vector3(cursorX + d.width / 2, 0, 0));
        widths.push(d.width);

        cursorX += d.width + spaceW;
      }

      group.userData.textAlign = textAlign;
      return { group, meshes, centers, widths, emphasisFlags, normalizedWords };
    }

  function transcriptionToTimedLines(transcription, wordsPerLine = 8) {
    const words = Array.isArray(transcription?.words) ? transcription.words : [];
    const lines = [];
    for (let i = 0; i < words.length; i += wordsPerLine) {
      const chunk = words.slice(i, i + wordsPerLine);
      if (!chunk.length) continue;
      const parsed = chunk.map(w => parseEmphasisToken(w.text ?? ''));
      const text = parsed.map(p => p.cleanText).join(' ');
      const startTime = Number(chunk[0].startTime ?? 0);
      const endTime = Number(chunk[chunk.length - 1].endTime ?? startTime);
      const normalizedWords = chunk.map((w, idx) => ({ ...w, text: parsed[idx].cleanText, emphasis: parsed[idx].isEmphasized }));
      lines.push({ text, startTime, endTime, words: normalizedWords });
    }
    return lines;
  }

  // -------------------------
  // Reveal animation
  // -------------------------
  function normalizeRevealStyle(style) {
    const id = String(style || '').trim();
    if (id === 'rise') return 'slide-up'; // legacy
    const valid = REVEAL_STYLE_OPTIONS.map(o => o.id);
    return valid.includes(id) ? id : 'slide-up';
  }

  function startReveal(mesh, now) {
    if (mesh.userData.revealed) return;

    mesh.userData.revealed = true;
    mesh.visible = true;
    mesh.userData.revealStart = now;
    mesh.material.opacity = 0;

    const style = normalizeRevealStyle(mesh?.userData?.revealStyle || cfg.revealStyle);
    mesh.userData.revealStyle = style;

    const baseStart = Math.max(1, cfg.revealStartScale);
    const basePop = Math.max(baseStart, cfg.revealPopScale);

    const params = {
      startScale: baseStart,
      popScale: basePop,
      rise: cfg.revealRise * 0.75,
      depth: cfg.revealZ * 0.55,
      axisXStart: 1,
      axisXEnd: 1,
      opacityFloor: 0.1,
    };

    if (style === 'grow-up') {
      params.startScale = Math.max(1, cfg.revealStartScale * 0.98);
      params.popScale = Math.max(params.startScale, cfg.revealPopScale * 0.96);
      params.rise = -Math.abs(cfg.revealRise) * 1.45;
      params.depth = -Math.abs(cfg.revealZ) * 1.2;
    } else if (style === 'bloom') {
      params.startScale = Math.max(0.85, cfg.revealStartScale * 0.9);
      params.popScale = Math.max(params.startScale, cfg.revealPopScale * 1.12);
      params.rise = cfg.revealRise * 0.25;
      params.depth = cfg.revealZ * 0.35;
      params.opacityFloor = 0.12;
    } else if (style === 'fade-scale') {
      params.startScale = Math.max(0.9, cfg.revealStartScale * 0.92);
      params.popScale = Math.max(params.startScale, cfg.revealPopScale * 0.98);
      params.rise = cfg.revealRise * 0.22;
      params.depth = cfg.revealZ * 0.3;
      params.opacityFloor = 0;
    } else if (style === 'word-fade') {
      params.startScale = 1;
      params.popScale = 1;
      params.rise = 0;
      params.depth = 0;
      params.opacityFloor = 0;
    } else if (style === 'char-fade') {
      params.startScale = 1;
      params.popScale = 1.02;
      params.rise = 0;
      params.depth = 0;
      params.axisXStart = 0.92;
      params.axisXEnd = 1;
      params.opacityFloor = 0;
    } else if (style === 'typewriter') {
      params.startScale = 1;
      params.popScale = 1;
      params.rise = cfg.revealRise * 0.15;
      params.depth = 0;
      params.axisXStart = 0.08;
      params.axisXEnd = 1;
      params.opacityFloor = 0.05;
    }

    mesh.userData.revealParams = params;
    mesh.userData.revealStartScale = params.startScale;
    mesh.userData.revealPopScale = params.popScale;
    mesh.userData.revealOffsetY = params.rise;
    mesh.userData.revealOffsetZ = params.depth;
    mesh.userData.axisXStart = params.axisXStart;
    mesh.userData.axisXEnd = params.axisXEnd;

    mesh.scale.set(params.axisXStart, params.startScale, params.startScale);
    mesh.position.set(
      mesh.userData.basePos.x,
      mesh.userData.basePos.y + params.rise,
      mesh.userData.basePos.z + params.depth
    );
  }

  function tickReveal(mesh, now) {
    if (!mesh.visible) return;
    const t0 = mesh.userData.revealStart;
    if (t0 === null) return;

    const elapsed = now - t0;
    const t = clamp01(elapsed / cfg.revealMs);
    const profile = getEmphasisProfile();
    const easeIn = smooth01(t);
    const params = mesh.userData.revealParams || {};
    const opacityEase = easeOutCubic(easeIn);

    const startScale = params.startScale ?? Math.max(1, cfg.revealStartScale);
    const popScale = params.popScale ?? cfg.revealPopScale;
    const rise = params.rise ?? 0;
    const depth = params.depth ?? 0;
    const axisXStart = params.axisXStart ?? 1;
    const axisXEnd = params.axisXEnd ?? 1;
    const style = mesh.userData.revealStyle || cfg.revealStyle;

    const liftEase = easeOutCubic(easeIn);
    const backEase = easeOutBack(easeIn, Math.max(0, cfg.revealOvershoot || 0));
    const styleScale = THREE.MathUtils.lerp(startScale, Math.max(startScale, popScale), backEase);
    const settleScale = THREE.MathUtils.lerp(styleScale, 1, liftEase);

    mesh.position.set(
      mesh.userData.basePos.x,
      mesh.userData.basePos.y + rise * (1 - liftEase),
      mesh.userData.basePos.z + depth * (1 - liftEase)
    );

    const emScale = emphasisScaleFor(mesh, elapsed, profile);
    let uni = settleScale * emScale;
    let axisX = axisXEnd;
    let opacity = Math.min(1, (params.opacityFloor ?? 0.1) + opacityEase * (1 - (params.opacityFloor ?? 0.1)));

    if (style === 'word-fade') {
      uni = emScale;
      axisX = 1;
      opacity = opacityEase;
    } else if (style === 'fade-scale') {
      uni = THREE.MathUtils.lerp(startScale, 1, liftEase) * emScale;
      axisX = THREE.MathUtils.lerp(axisXStart, axisXEnd, liftEase);
      opacity = opacityEase;
    } else if (style === 'char-fade') {
      const chars = Math.max(1, mesh.userData.wordLength || 1);
      const charPhase = clamp01(easeIn * chars);
      axisX = THREE.MathUtils.lerp(axisXStart, axisXEnd, charPhase);
      opacity = charPhase;
      uni = emScale;
    } else if (style === 'typewriter') {
      const chars = Math.max(1, mesh.userData.wordLength || 1);
      const charPhase = clamp01(easeIn * chars);
      axisX = THREE.MathUtils.lerp(axisXStart, axisXEnd, charPhase);
      opacity = Math.max(params.opacityFloor ?? 0.05, charPhase);
    }

    mesh.material.opacity = opacity;

    mesh.scale.set(axisX * emScale, uni, uni);

    if (t >= 1) {
      mesh.userData.revealStart = null;
      mesh.material.opacity = 1;
      mesh.scale.setScalar(emphasisScaleFor(mesh, cfg.revealMs + (profile?.emphasisSettleMs ?? 0), profile));
      mesh.position.copy(mesh.userData.basePos);
    }
  }

  function updateActiveHighlight(meshes, activeIdx, emphasisProfile, dt) {
    if (!Array.isArray(meshes)) return;
    const baseColor = new THREE.Color(cfg.color);
    const smooth = Math.max(1, cfg.highlightLambda || 12);

    const active = (typeof activeIdx === 'number' && activeIdx >= 0) ? activeIdx : null;

    for (let i = 0; i < meshes.length; i++) {
      const m = meshes[i];
      if (!m) continue;

      const neighborWeight = Math.max(0, Number(cfg.neighborHighlight || 0));
      const target = (active === null)
        ? 0
        : (i === active ? 1 : (Math.abs(i - active) === 1 ? neighborWeight : 0));
      const prev = Number(m.userData.activeWeight || 0);
      const next = damp(prev, target, smooth, dt);
      m.userData.activeWeight = next;

      const emphasisTone = m.userData.emphasis ? 0.45 : 0.22;
      const boost = (i === activeIdx)
        ? (cfg.activeGlowBoost || 0.22)
        : (cfg.neighborGlowBoost || 0.12);
      const emissiveScale = emphasisTone + boost * next;
      m.material.emissive.copy(baseColor).multiplyScalar(emissiveScale);
      m.material.emissiveIntensity = 1.05 + (m.userData.emphasis ? 0.35 : 0.15) * next;

      // Keep emphasis scale visible even after reveal completes
      if (m.userData.revealStart === null) {
        const baseScale = m.userData.emphasis
          ? 1 + ((emphasisProfile?.emphasisScale ?? 1) - 1) * 0.65
          : 1;
        const activeScale = 1 + 0.08 * next;
        m.scale.setScalar(baseScale * activeScale);
      }
    }
  }

  // -------------------------
  // Camera target shaping
  // -------------------------
  function computeCenterBounds(centers) {
    let minX = Infinity;
    let maxX = -Infinity;
    for (const c of centers) {
      if (!c) continue;
      if (c.x < minX) minX = c.x;
      if (c.x > maxX) maxX = c.x;
    }
    return { minX, maxX };
  }

  function endBias(u, maxBias) {
    const t = clamp01((u - 0.70) / 0.30);
    return easeOutCubic(t) * maxBias;
  }

  function shapeTargetWithBounds(target, u, centers, widths, bounds, extraBias = 0) {
    if (!centers?.length) return target;
    const { minX, maxX } = bounds ?? computeCenterBounds(centers);
    if (!isFinite(minX) || !isFinite(maxX)) return target;

    const lastW = widths?.[widths.length - 1] ?? 0;
    const baseBias = Math.max(0, cfg.endOverhangPx + (lastW * cfg.endOverhangFactor));
    const smoothBias = endBias(u, baseBias) + (extraBias || 0);

    const out = target.clone();
    const lead = Math.max(0, cfg.trackLeadPx);
    const biasedX = Math.max(minX - lead, target.x + smoothBias);
    const clampedX = Math.min(maxX + baseBias, biasedX);

    const blendWindow = Math.max(0.01, cfg.endOverhangBlendU || 0.1);
    const blendStart = Math.max(0, 1 - blendWindow);
    let terminalGuard = -Infinity;
    if (u >= blendStart) {
      const tNorm = clamp01((u - blendStart) / blendWindow);
      const eased = smooth01(tNorm);
      terminalGuard = maxX + baseBias * eased;
    }

    out.x = Math.max(clampedX, terminalGuard);
    return out;
  }

  const requiredDistanceForSpan = (window.AnimationHelpers && typeof window.AnimationHelpers.requiredDistanceForSpan === 'function')
    ? window.AnimationHelpers.requiredDistanceForSpan
    : function requiredDistanceForSpanFallback(span, aspect = 1, fovDeg = 50, baseDistance = 1, padding = 0) {
        const safeSpan = Math.max(0, span) + Math.max(0, padding) * 2;
        if (safeSpan === 0) return baseDistance;
        const fov = Math.max(1e-3, Number(fovDeg) || 50) * Math.PI / 180;
        const asp = Math.max(0.1, Number(aspect) || 1);
        const denom = Math.tan(fov / 2) * asp;
        if (!isFinite(denom) || denom <= 0) return baseDistance;
        const needed = (safeSpan / 2) / denom;
        return Math.max(baseDistance, needed);
      };

  function computeFocusSpan(activeIdx, widths = [], bounds) {
    const span = Math.max(0, (bounds?.maxX ?? 0) - (bounds?.minX ?? 0));
    if (!Array.isArray(widths) || widths.length === 0) return Math.max(0.6, span * 0.5);

    const safeIdx = Math.max(0, Math.min(typeof activeIdx === 'number' && activeIdx >= 0 ? activeIdx : Math.floor(widths.length / 2), widths.length - 1));
    const prev = Number(widths[Math.max(0, safeIdx - 1)] || 0);
    const cur = Number(widths[safeIdx] || 0);
    const next = Number(widths[Math.min(widths.length - 1, safeIdx + 1)] || 0);

    const trio = prev + cur + next;
    const avg = widths.reduce((s, w) => s + (Number(w) || 0), 0) / Math.max(1, widths.length);
    const maxW = widths.reduce((m, w) => Math.max(m, Number(w) || 0), 0);

    return Math.max(trio, avg * 2.4, maxW * 1.25, span * 0.5, 0.6);
  }

  function frameCameraDistance(baseDistance, activeIdx, widths, bounds) {
    const focusSpan = computeFocusSpan(activeIdx, widths, bounds);
    const padding = Math.max(0.05, cfg.trackLeadPx + cfg.endOverhangPx * 0.5);
    return requiredDistanceForSpan(focusSpan, camera.aspect, camera.fov, baseDistance, padding);
  }

  function easeOutEndU(u) {
    const e = clamp01(cfg.endEaseOutU);
    if (e <= 0.0001) return u;
    const start = 1 - e;
    if (u <= start) return u;
    const t = clamp01((u - start) / e);
    const eased = easeOutCubic(t);
    return start + eased * e;
  }

  function centersWithGroupY(centers, groupY) {
    return centers.map(v => new THREE.Vector3(v.x, v.y + groupY, v.z));
  }

  // -------------------------
  // Animation: timed
  // -------------------------
  function animateLineGlideWithTiming(lineObj, onComplete) {
    const { meshes, centers, widths, words, startTime, endTime, group, emphasisFlags } = lineObj;
    const n = centers.length;
    const emphasisProfile = getEmphasisProfile();
    const lineProfile = lineObj.profileSettings || getLineProfile(lineObj.profileId);
    const activeRevealStyle = lineObj.revealStyleOverride || lineProfile?.revealStyle || cfg.revealStyle;

    for (const m of meshes) {
      m.visible = false;
      m.material.opacity = 0;
      m.userData.revealStart = null;
      m.userData.revealed = false;
      m.scale.setScalar(1);
      m.position.copy(m.userData.basePos);
      m.userData.revealStyle = activeRevealStyle;
    }

    if (n === 0) { onComplete?.(); return; }

    const c2 = centersWithGroupY(centers, group.position.y);
    const curve = new THREE.CatmullRomCurve3(c2, false, 'catmullrom', 0.5);

    const bounds = computeCenterBounds(c2);

    const ARC_SAMPLES = Math.max(320, n * 120);
    const lengths = curve.getLengths(ARC_SAMPLES);
    const totalLen = lengths[lengths.length - 1];

    const durationSec = Math.max(0.05, (endTime - startTime));
    const totalMs = durationSec * 1000;
    const start = performance.now();

    let camX = camera.position.x;
    let camY = camera.position.y;
    let lookAtX = camera.position.x;
    let lookAtY = camera.position.y;

    const followLambda = cfg.followLambda * (lineProfile?.followMult ?? 1);
    const lookAheadU   = Math.max(0, cfg.curveLookAheadU + (lineProfile?.lookAheadOffset ?? 0));
    const lookLambda   = cfg.lookAtLambda * (lineProfile?.lookAtMult ?? 1);
    const baseCamDistance  = cfg.cameraDistance + (lineProfile?.cameraDistanceOffset ?? 0);
    let camDistance = baseCamDistance;
    let lastNow = performance.now();
    let targetX = camera.position.x;
    let targetY = camera.position.y;

    function frame(now) {
      const dt = Math.max(0.001, (now - lastNow) / 1000);
      lastNow = now;

      const elapsed = now - start;
      const uRaw = Math.min(elapsed / totalMs, 1);
      const eased = smooth01(uRaw);
      const u = easeOutEndU(eased);

      const currentTime = startTime + (uRaw * durationSec);
      const activeIdx = computeActiveWordIndex(Array.isArray(words) && words.length === meshes.length ? words : null, currentTime, uRaw, n);
      const dist = u * totalLen;
      let idx = 0;
      while (idx < lengths.length && lengths[idx] < dist) idx++;

      const denom = Math.max(1, lengths.length - 1);
      const t = idx / denom;
      const activeProgress = (typeof activeIdx === 'number' && activeIdx >= 0)
        ? clamp01(activeIdx / Math.max(1, n - 1))
        : 0;
      const adjustedLookAhead = lookAheadU * (0.32 + 0.28 * activeProgress);
      const t2 = Math.min(1, t + adjustedLookAhead);
      const isEmphasis = activeIdx >= 0 && Array.isArray(emphasisFlags) && emphasisFlags[activeIdx];
      const isTerminal = activeIdx === (n - 1);
      const bias = computeEmphasisBias(emphasisProfile, activeIdx, emphasisFlags, widths, uRaw) + (lineProfile?.endBiasPx ?? 0);

      let target = curve.getPointAt(t2);
      const focus = (activeIdx >= 0 && activeIdx < c2.length) ? c2[activeIdx] : null;
      if (focus) {
        const blend = Math.min(0.72, 0.28 + (isEmphasis ? 0.10 : 0) + (isTerminal ? 0.12 : 0));
        target.lerp(focus, blend);
      }
      target = shapeTargetWithBounds(target, uRaw, c2, widths, bounds, bias);

      const targetLambda = Math.max(0.1, followLambda * 1.05);
      targetX = damp(targetX, target.x, targetLambda, dt);
      targetY = damp(targetY, target.y, targetLambda, dt);

      if (Array.isArray(words) && words.length === meshes.length) {
        for (let k = 0; k < words.length; k++) {
          if (currentTime >= Number(words[k].startTime ?? 0)) startReveal(meshes[k], now);
        }
      } else {
        const p = uRaw * (n - 1);
        const revealIdx = Math.min(n - 1, Math.floor(p + cfg.revealWordLead));
        for (let k = 0; k <= revealIdx; k++) startReveal(meshes[k], now);
      }

      for (const m of meshes) tickReveal(m, now);

      updateActiveHighlight(meshes, activeIdx, emphasisProfile, dt);

      const followScale = (isEmphasis ? (emphasisProfile?.emphasisFollowMult ?? 1) : 1) * (isTerminal ? (emphasisProfile?.terminalFollowMult ?? 1) : 1);
      const lookScale = (isEmphasis ? (emphasisProfile?.emphasisLookAtMult ?? 1) : 1) * (isTerminal ? (emphasisProfile?.terminalLookAtMult ?? 1) : 1);

      const camLambda = Math.max(0.08, followLambda * followScale * 0.9);
      camX = damp(camX, targetX, camLambda, dt);
      camY = damp(camY, targetY, camLambda, dt);

      const desiredDistance = frameCameraDistance(baseCamDistance, activeIdx, widths, bounds);
      camDistance = damp(camDistance, desiredDistance, Math.max(2.5, followLambda * 0.55), dt);

      const lookTargetLambda = Math.max(0.08, lookLambda * lookScale * 0.9);
      lookAtX = damp(lookAtX, targetX, lookTargetLambda, dt);
      lookAtY = damp(lookAtY, targetY, lookTargetLambda, dt);

      camera.position.set(camX, camY, camDistance);
      camera.lookAt(lookAtX, lookAtY, target.z);

      renderer.render(scene, camera);

      if (uRaw < 1) requestAnimationFrame(frame);
      else {
        for (const m of meshes) {
          m.visible = true;
          m.material.opacity = 1;
          m.userData.revealStart = null;
          m.scale.setScalar(1);
          m.position.copy(m.userData.basePos);
        }
        const terminalHold = (emphasisProfile?.terminalHoldMs ?? 0) + ((Array.isArray(emphasisFlags) && emphasisFlags[n - 1]) ? (emphasisProfile?.emphasisHoldMs ?? 0) : 0);
        const profileHold = Math.max(0, (lineProfile?.holdMs ?? 0) + (lineObj?.holdMs ?? 0));
        const hold = Math.max(0, cfg.lineHoldMsAfterComplete + terminalHold + profileHold);
        setTimeout(() => onComplete?.(), hold);
      }
    }

    requestAnimationFrame(frame);
  }

  // -------------------------
  // Animation: fallback
  // -------------------------
  function animateLineGlideFallback(lineObj, onComplete){
    const { meshes, centers, widths, group, emphasisFlags } = lineObj;
    const n = centers.length;
    const emphasisProfile = getEmphasisProfile();
    const lineProfile = lineObj.profileSettings || getLineProfile(lineObj.profileId);
    const activeRevealStyle = lineObj.revealStyleOverride || lineProfile?.revealStyle || cfg.revealStyle;

    for (const m of meshes) {
      m.visible = false;
      m.material.opacity = 0;
      m.userData.revealStart = null;
      m.userData.revealed = false;
      m.scale.setScalar(1);
      m.position.copy(m.userData.basePos);
      m.userData.revealStyle = activeRevealStyle;
    }

    if (n === 0) { onComplete?.(); return; }

    const c2 = centersWithGroupY(centers, group.position.y);
    const curve = new THREE.CatmullRomCurve3(c2, false, 'catmullrom', 0.5);

    const bounds = computeCenterBounds(c2);

    const ARC_SAMPLES = Math.max(320, n * 120);
    const lengths = curve.getLengths(ARC_SAMPLES);
    const totalLen = lengths[lengths.length - 1];

    const profileDurationMs = typeof lineObj.durationMs === 'number' ? lineObj.durationMs : null;
    const wordsPerSec = Math.max(0.1, cfg.wordsPerSecond * (lineProfile?.speedMultiplier ?? 1));
    const totalMs = profileDurationMs ?? (n * (1000 / wordsPerSec));
    const start = performance.now();

    let camX = camera.position.x;
    let camY = camera.position.y;
    let lookAtX = camera.position.x;
    let lookAtY = camera.position.y;

    const revealWordLead = cfg.revealWordLead;
    const followLambda   = cfg.followLambda * (lineProfile?.followMult ?? 1);
    const lookAheadU     = Math.max(0, cfg.curveLookAheadU + (lineProfile?.lookAheadOffset ?? 0));
    const lookLambda     = cfg.lookAtLambda * (lineProfile?.lookAtMult ?? 1);
    const baseCamDistance    = cfg.cameraDistance + (lineProfile?.cameraDistanceOffset ?? 0);
    let camDistance = baseCamDistance;
    let lastNow = performance.now();
    let targetX = camera.position.x;
    let targetY = camera.position.y;

    function frame(now){
      const dt = Math.max(0.001, (now - lastNow) / 1000);
      lastNow = now;

      const elapsed = now - start;
      const uRaw = Math.min(elapsed / totalMs, 1);
      const eased = smooth01(uRaw);
      const u = easeOutEndU(eased);

      const activeIdx = computeActiveWordIndex(null, 0, uRaw, n);
      const dist = u * totalLen;
      let idx = 0;
      while (idx < lengths.length && lengths[idx] < dist) idx++;

      const denom = Math.max(1, lengths.length - 1);
      const t = idx / denom;
      const activeProgress = (typeof activeIdx === 'number' && activeIdx >= 0)
        ? clamp01(activeIdx / Math.max(1, n - 1))
        : 0;
      const adjustedLookAhead = lookAheadU * (0.32 + 0.28 * activeProgress);
      const t2 = Math.min(1, t + adjustedLookAhead);

      const isEmphasis = activeIdx >= 0 && Array.isArray(emphasisFlags) && emphasisFlags[activeIdx];
      const isTerminal = activeIdx === (n - 1);
      const bias = computeEmphasisBias(emphasisProfile, activeIdx, emphasisFlags, widths, uRaw) + (lineProfile?.endBiasPx ?? 0);

      let target = curve.getPointAt(t2);
      const focus = (activeIdx >= 0 && activeIdx < c2.length) ? c2[activeIdx] : null;
      if (focus) {
        const blend = Math.min(0.72, 0.28 + (isEmphasis ? 0.10 : 0) + (isTerminal ? 0.12 : 0));
        target.lerp(focus, blend);
      }
      target = shapeTargetWithBounds(target, uRaw, c2, widths, bounds, bias);

      const targetLambda = Math.max(0.1, followLambda * 1.05);
      targetX = damp(targetX, target.x, targetLambda, dt);
      targetY = damp(targetY, target.y, targetLambda, dt);

      const p = uRaw * (n - 1);
      const revealIdx = Math.min(n - 1, Math.floor(p + revealWordLead));
      for (let k = 0; k <= revealIdx; k++) startReveal(meshes[k], now);

      for (const m of meshes) tickReveal(m, now);

      updateActiveHighlight(meshes, activeIdx, emphasisProfile, dt);

      const followScale = (isEmphasis ? (emphasisProfile?.emphasisFollowMult ?? 1) : 1) * (isTerminal ? (emphasisProfile?.terminalFollowMult ?? 1) : 1);
      const lookScale = (isEmphasis ? (emphasisProfile?.emphasisLookAtMult ?? 1) : 1) * (isTerminal ? (emphasisProfile?.terminalLookAtMult ?? 1) : 1);

      const camLambda = Math.max(0.08, followLambda * followScale * 0.9);
      camX = damp(camX, targetX, camLambda, dt);
      camY = damp(camY, targetY, camLambda, dt);

      const desiredDistance = frameCameraDistance(baseCamDistance, activeIdx, widths, bounds);
      camDistance = damp(camDistance, desiredDistance, Math.max(2.5, followLambda * 0.55), dt);

      const lookTargetLambda = Math.max(0.08, lookLambda * lookScale * 0.9);
      lookAtX = damp(lookAtX, targetX, lookTargetLambda, dt);
      lookAtY = damp(lookAtY, targetY, lookTargetLambda, dt);

      camera.position.set(camX, camY, camDistance);
      camera.lookAt(lookAtX, lookAtY, target.z);

      renderer.render(scene, camera);

      if (uRaw < 1) requestAnimationFrame(frame);
      else {
        for (const m of meshes) {
          m.visible = true;
          m.material.opacity = 1;
          m.userData.revealStart = null;
          m.scale.setScalar(1);
          m.position.copy(m.userData.basePos);
        }
        const terminalHold = (emphasisProfile?.terminalHoldMs ?? 0) + ((Array.isArray(emphasisFlags) && emphasisFlags[n - 1]) ? (emphasisProfile?.emphasisHoldMs ?? 0) : 0);
        const profileHold = Math.max(0, (lineProfile?.holdMs ?? 0) + (lineObj?.holdMs ?? 0));
        const hold = Math.max(0, cfg.lineHoldMsAfterComplete + terminalHold + profileHold);
        setTimeout(() => onComplete?.(), hold);
      }
    }

    requestAnimationFrame(frame);
  }

  // -------------------------
  // Sequencer + stacking
  // -------------------------
  let isPlaying = false;

  function clearAllLinesFromScene() {
    for (const obj of lineObjs) {
      if (obj?.group) scene.remove(obj.group);
    }
    stackedGroups.length = 0;
    stackedLineCount = 0;
  }

  function computeGroupHeight(group) {
    if (!group) return cfg.textSize;
    tmpBox.makeEmpty();
    tmpBox.setFromObject(group);
    if (tmpBox.isEmpty()) return cfg.textSize;
    return Math.max(cfg.textSize * 0.9, tmpBox.max.y - tmpBox.min.y);
  }

  function reflowStackedGroups() {
    if (!cfg.keepPreviousLinesVisible || !cfg.stackLines) return;
    const gap = Number(cfg.stackLineGap || 0.22);
    const paragraphGap = Math.max(gap, Number(cfg.paragraphGap || (cfg.textSize + gap)));
    let cursor = 0;
    for (const g of stackedGroups) {
      if (!g) continue;
      const breaksBefore = Math.max(0, Number(g.userData?.paragraphBreaks || 0));
      cursor += breaksBefore * paragraphGap;

      const h = computeGroupHeight(g);
      g.position.y = -cursor;
      cursor += h + gap;
    }
    stackedLineCount = stackedGroups.length;
  }

  function enforceStackLimit() {
    if (!cfg.keepPreviousLinesVisible) return;
    if (!cfg.stackLines) return;
    const max = Math.max(1, Number(cfg.stackMaxLines || 1));

    while (stackedGroups.length > max) {
      const oldest = stackedGroups.shift();
      if (oldest) scene.remove(oldest);
    }

    stackedLineCount = stackedGroups.length;
    reflowStackedGroups();
  }

  function runSequence(lineIdx = 0) {
    if (lineIdx >= lineObjs.length) {
      isPlaying = false;
      const rawLineCount = Math.max(lineImportStats?.rawLineCount || 0, lineObjs.length);
      const segmentNote = (lineImportStats?.rawLineCount && lineImportStats.rawLineCount !== lineObjs.length)
        ? ` (segments: ${lineObjs.length})`
        : '';
      setStatus(transcriptionData
        ? `Done. (Resolve) Lines: ${rawLineCount}${segmentNote}  Words: ${transcriptionData.words?.length ?? 0}`
        : `Done. (demo-lines.txt) Lines: ${rawLineCount}${segmentNote}`
      );
      return;
    }

    const current = lineObjs[lineIdx];

    const startLine = () => {
      // Reset mesh visibility/opacities in case of prior runs
      if (Array.isArray(current.meshes)) {
        for (const m of current.meshes) {
          if (!m) continue;
          m.visible = true;
          m.material.opacity = 0;
          m.userData.revealed = false;
          m.userData.revealStart = null;
        }
      }

      if (cfg.keepPreviousLinesVisible && cfg.stackLines) {
        stackedGroups.push(current.group);
        enforceStackLimit();
        reflowStackedGroups();
      } else {
        current.group.position.y = 0;
      }

      scene.add(current.group);

      const hasTiming = (typeof current.startTime === 'number' && typeof current.endTime === 'number');
      const done = () => {
        if (!cfg.keepPreviousLinesVisible || !cfg.stackLines) scene.remove(current.group);
        runSequence(lineIdx + 1);
      };

      if (hasTiming) animateLineGlideWithTiming(current, done);
      else animateLineGlideFallback(current, done);
    };

    const pauseMs = Math.max(0, current.pauseMs || 0);
    if (pauseMs > 0) setTimeout(startLine, pauseMs);
    else startLine();
  }

  async function replay() {
    if (isPlaying) return;
    try {
      setStatus('Rebuilding + replaying…');
      const font = await loadFontFromSelection();
      fontRef = font;

      clearAllLinesFromScene();

      if (captionSourceState.mode === 'srt' || captionSourceState.mode === 'cues') {
        await loadCaptionSource();
        setTimelineTime(0);
        playTimelinePlayback();
        return;
      }

      if (transcriptionData && Array.isArray(transcriptionData.words) && transcriptionData.words.length) {
        const wpl = Number(wplEl.value);
        const timedLines = transcriptionToTimedLines(transcriptionData, wpl);
        buildFromTimedLines(font, timedLines);
      } else {
        const lines = await loadLines(cfg.linesUrl);
        buildFromPlainLines(font, lines);
      }

      if (lineObjs.length === 0) {
        setStatus('No lines to play.');
        return;
      }
      prepareTimelineFromLineObjs(lineObjs);
      setTimelineTime(0);
      playTimelinePlayback();
    } catch (err) {
      isPlaying = false;
      setStatus('Replay failed: ' + String(err));
    }
  }

  function buildFromTimedLines(font, timedLines) {
    clearAllLinesFromScene();
    lineImportStats = { rawLineCount: Array.isArray(timedLines) ? timedLines.length : 0, segmentCount: 0 };
    lineObjs = [];
    for (const ln of timedLines) {
      const obj = buildLine(font, ln.text, ln.words);
      obj.startTime = ln.startTime;
      obj.endTime = ln.endTime;
      obj.words = obj.normalizedWords || ln.words;
      obj.profileId = DEFAULT_LINE_PROFILE_ID;
      obj.profileSettings = getLineProfile(obj.profileId);
      obj.pauseMs = 0;
      obj.holdMs = 0;
      obj.paragraphBreaks = 0;
      obj.revealStyleOverride = obj.profileSettings?.revealStyle || null;
      obj.group.userData.paragraphBreaks = obj.paragraphBreaks;
      const durationMs = (typeof obj.startTime === 'number' && typeof obj.endTime === 'number')
        ? Math.max(0, (obj.endTime - obj.startTime) * 1000)
        : 0;
      obj.durationMs = Math.max(50, durationMs);
      lineObjs.push(obj);
    }

    lineImportStats.segmentCount = lineObjs.length;
  }

  function buildFromPlainLines(font, lines) {
    clearAllLinesFromScene();
    lineImportStats = { rawLineCount: Array.isArray(lines) ? lines.length : 0, segmentCount: 0 };
    lineObjs = [];
    const segments = parseScriptLines(lines, DEFAULT_LINE_PROFILE_ID);
    for (const seg of segments) {
      const obj = buildLine(font, seg.text);
      obj.profileId = seg.profileId || DEFAULT_LINE_PROFILE_ID;
      obj.profileSettings = getLineProfile(obj.profileId);
      obj.pauseMs = Math.max(0, seg.pauseMs || 0);
      obj.holdMs = Math.max(0, seg.holdMs || 0);
      obj.paragraphBreaks = Math.max(0, seg.breaks || 0);
      obj.revealStyleOverride = obj.profileSettings?.revealStyle || null;

      obj.group.userData.paragraphBreaks = obj.paragraphBreaks;

      const punctuationCount = (seg.text.match(/[.,;:!?…—-]/g) || []).length;
      const wordCount = obj.normalizedWords?.length ?? 0;
      obj.durationMs = estimateSegmentDurationMs(wordCount, punctuationCount, obj.profileSettings);

      lineObjs.push(obj);
    }

    lineImportStats.segmentCount = lineObjs.length;
  }

  // -------------------------
  // Record / export
  // -------------------------
  let mediaRecorder = null;
  let recordedChunks = [];
  let recordingActive = false;
  let recordingUiState = null;

  function pickMimeType() {
    const candidates = ['video/webm;codecs=vp9','video/webm;codecs=vp8','video/webm'];
    for (const t of candidates) {
      if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t;
    }
    return '';
  }

  if (!canvas.captureStream || !window.MediaRecorder) {
    btnRecord.disabled = true;
    btnRecord.title = 'Recording not supported in this browser.';
  }

  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 5000);
  }

  function startRecording({ resetTimeline = false, autoPlay = false, autoStopAtEnd = false, preRollMs = 180 } = {}) {
    if (recordingActive) return;
    if (!canvas.captureStream || !window.MediaRecorder) {
      setStatus('Recording not supported in this browser.\nTry Chrome/Edge on desktop.\n(iOS Safari often blocks WebM MediaRecorder)');
      btnRecord.disabled = true;
      return;
    }

    if (resetTimeline && timelineLines.length) {
      setTimelineTime(0);
    }

    const stream = canvas.captureStream(60);
    const mimeType = pickMimeType();

    try {
      mediaRecorder = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
    } catch (e) {
      setStatus('MediaRecorder init failed:\n' + String(e));
      return;
    }

    recordedChunks = [];
    recordingActive = true;
    btnRecord.disabled = true;
    btnStop.disabled = false;
    recordingUiState = {
      collapsed: ui.classList.contains('collapsed'),
    };
    setUiCollapsed(true);

    mediaRecorder.ondataavailable = (ev) => {
      if (ev.data && ev.data.size > 0) recordedChunks.push(ev.data);
    };

    mediaRecorder.onstop = () => {
      recordingActive = false;
      btnRecord.style.display = '';
      btnStop.style.display = 'none';
      btnRecord.disabled = false;
      btnStop.disabled = true;
      if (recordingUiState) {
        setUiCollapsed(recordingUiState.collapsed);
        recordingUiState = null;
      }

      const blob = new Blob(recordedChunks, { type: (mediaRecorder && mediaRecorder.mimeType) || 'video/webm' });
      recordedChunks = [];

      const stamp = new Date().toISOString().replace(/[:.]/g,'-');
      downloadBlob(blob, `captioner-${stamp}.webm`);
      setStatus('Saved recording to device downloads.\nIf you’re on iOS: you may need "Share → Save Video" depending on browser.');
    };

    mediaRecorder.start(250);
    btnRecord.style.display = 'none';
    btnStop.style.display = '';
    setStatus(`Recording…\nMime: ${mediaRecorder.mimeType || '(default)'}`);

    if (timelineLines.length) {
      renderTimelineFrame(performance.now());
    }

    if (autoPlay && timelineLines.length && !timelineState.isPlaying) {
      const triggerPlay = () => {
        playTimelinePlayback({ onStop: autoStopAtEnd ? () => stopRecording() : undefined });
      };
      if (preRollMs > 0) setTimeout(triggerPlay, preRollMs);
      else triggerPlay();
    }
  }

  function stopRecording() {
    if (!mediaRecorder || !recordingActive) return;
    try { mediaRecorder.stop(); } catch (e) { setStatus('Stop failed:\n' + String(e)); }
  }

  btnRecord.addEventListener('click', () => {
    if (!timelineLines.length) {
      setStatus('No timeline captions loaded.');
      return;
    }
    startRecording({ resetTimeline: true, autoPlay: true, autoStopAtEnd: true });
  });
  btnStop.addEventListener('click', stopRecording);

  // -------------------------
  // Advanced cfg editor
  // -------------------------
  const CFG_SCHEMA = [
      ['fontId', 'text', 'fontId', 'font preset id (use dropdown)'],
      ['fontUrl', 'text', 'fontUrl', 'font URL (custom/preset override)'],
      ['fontFormat', 'text', 'fontFormat', 'auto/ttf/typeface (auto recommended)'],
      ['typographyProfile', 'text', 'typographyProfile', 'typography preset id (use dropdown)'],
      ['textAlign', 'text', 'textAlign', 'left, center, or right alignment'],
      ['textSize', 'number', 'textSize', 'word size in world units (rebuild needed)'],
      ['textDepth', 'number', 'textDepth', 'extrusion depth (rebuild needed)'],
      ['theme', 'text', 'theme', 'dark or light'],
    ['backgroundColor', 'text', 'backgroundColor', 'background hex (set by theme)'],
    ['color', 'text', 'color', 'hex color (e.g. 0xffffff)'],
    ['cameraDistance', 'number', 'cameraDistance', 'z distance of camera'],
    ['wordsPerSecond', 'number', 'wordsPerSecond', 'fallback speed mode only'],
    ['curveLookAheadU', 'number', 'curveLookAheadU', '0.01..0.08 recommended'],
    ['followLambda', 'number', 'followLambda', '12 floaty, 35 tight'],
    ['lookAtLambda', 'number', 'lookAtLambda', 'softens look-at easing'],
    ['revealWordLead', 'number', 'revealWordLead', 'reveal early (fallback)'],
    ['spaceMultiplier', 'number', 'spaceMultiplier', 'inter-word spacing'],
    ['revealMs', 'number', 'revealMs', 'reveal anim duration ms'],
    ['revealStartScale', 'number', 'revealStartScale', 'initial scale at reveal'],
    ['revealPopScale', 'number', 'revealPopScale', 'pop scale'],
    ['revealRise', 'number', 'revealRise', 'rise offset'],
    ['revealZ', 'number', 'revealZ', 'z push'],
    ['revealOvershoot', 'number', 'revealOvershoot', 'back overshoot'],
    ['revealStyle', 'text', 'revealStyle', 'rise or grow-up'],
    ['emphasisProfile', 'text', 'emphasisProfile', 'documentary or minimal'],
    ['endOverhangFactor', 'number', 'endOverhangFactor', '× last-word width near end'],
    ['endOverhangPx', 'number', 'endOverhangPx', 'extra push in world units'],
    ['trackLeadPx', 'number', 'trackLeadPx', 'left clamp padding'],
    ['endOverhangBlendU', 'number', 'endOverhangBlendU', 'blend-in fraction near end'],
    ['endEaseOutU', 'number', 'endEaseOutU', 'slow end fraction'],
    ['lineHoldMsAfterComplete', 'number', 'lineHoldMsAfterComplete', 'ms pause after each line'],
    ['stackLines', 'text', 'stackLines', 'true/false (when keepPrev true)'],
    ['stackLineGap', 'number', 'stackLineGap', 'vertical gap between stacked lines'],
    ['stackAnchor', 'text', 'stackAnchor', 'bottom or center'],
    ['stackMaxLines', 'number', 'stackMaxLines', 'max stacked lines visible'],
    ['paragraphGap', 'number', 'paragraphGap', 'extra gap when [BREAK]/[BR] tokens appear']
  ];

  const cfgInputs = new Map();

  function buildCfgEditorUI() {
    cfgGrid.innerHTML = '';
    cfgInputs.clear();

    for (const [key, type, label, help] of CFG_SCHEMA) {
      const row = document.createElement('div');
      row.className = 'cfgrow';

      const lab = document.createElement('label');
      lab.textContent = label;

      const sm = document.createElement('small');
      sm.textContent = help;
      lab.appendChild(sm);

      const input = document.createElement('input');
      input.type = (type === 'number') ? 'number' : 'text';
      input.step = (type === 'number') ? 'any' : undefined;

      input.placeholder = String(DEFAULT_CFG[key] ?? '');
      input.value = '';

      row.appendChild(lab);
      row.appendChild(input);
      cfgGrid.appendChild(row);

      cfgInputs.set(key, input);
    }
  }

  function applyCfgFromInputs() {
      for (const [key, input] of cfgInputs.entries()) {
        const raw = (input.value ?? '').trim();
        if (!raw) { cfg[key] = DEFAULT_CFG[key]; continue; }

      const spec = CFG_SCHEMA.find(x => x[0] === key);
      const type = spec ? spec[1] : 'text';

      if (type === 'number') {
        const v = Number(raw);
        if (!isFinite(v)) { setStatus(`cfg apply error:\n${key} must be a number`); return false; }
        cfg[key] = v;
      } else {
        if (raw.toLowerCase() === 'true') cfg[key] = true;
        else if (raw.toLowerCase() === 'false') cfg[key] = false;
        else cfg[key] = raw;
        }
      }

      cfg.textAlign = (AnimationHelpers.normalizeTextAlign?.(cfg.textAlign)) || 'center';

      keepPrevEl.checked = !!cfg.keepPreviousLinesVisible;
      ohValEl.textContent = Number(cfg.endOverhangFactor).toFixed(2);
      ohEl.value = String(cfg.endOverhangFactor);
      revealStyleSelect.value = cfg.revealStyle;
      textAlignSelect.value = cfg.textAlign;
      emphasisProfileSelect.value = cfg.emphasisProfile;

      baseMat = createBaseMaterial();

    const bg = new THREE.Color(cfg.backgroundColor ?? DEFAULT_CFG.backgroundColor ?? 0x000000);
    scene.background = bg.clone();
    renderer.setClearColor(bg, 1);
    document.body.style.background = `#${bg.getHexString()}`;
    lightingRig?.updatePalette?.({ text: cfg.color, background: cfg.backgroundColor });
    refreshAllMeshMaterials();

    persistState();

    return true;
  }

  function resetCfgInputs() {
    for (const [key, input] of cfgInputs.entries()) {
      input.value = '';
      input.placeholder = String(DEFAULT_CFG[key] ?? '');
    }
    Object.assign(cfg, structuredClone(DEFAULT_CFG));
    keepPrevEl.checked = !!cfg.keepPreviousLinesVisible;
      fontSelect.value = cfg.fontId;
      fontUrlInput.value = cfg.fontUrl;
      revealStyleSelect.value = cfg.revealStyle;
      textAlignSelect.value = cfg.textAlign;
      emphasisProfileSelect.value = cfg.emphasisProfile;
      ohEl.value = String(cfg.endOverhangFactor);
      ohValEl.textContent = Number(cfg.endOverhangFactor).toFixed(2);
    setStatus('cfg reset to defaults.\n(Rebuild on Replay)');
    persistState();
  }

  cfgResetBtn.addEventListener('click', () => resetCfgInputs());

  async function rebuildSceneFromCurrentSource() {
    if (!fontRef) return;

    if (transcriptionData && Array.isArray(transcriptionData.words) && transcriptionData.words.length) {
      const wpl = Number(wplEl.value);
      const timedLines = transcriptionToTimedLines(transcriptionData, wpl);
      buildFromTimedLines(fontRef, timedLines);
      prepareTimelineFromLineObjs(lineObjs);
      setTimelineTime(timelineState.currentMs || 0);
      renderTimelineFrame(performance.now());
      return;
    }

    if ((captionSourceState.mode === 'srt' || captionSourceState.mode === 'cues') && timelineLineSource.length) {
      buildFromTimedLines(fontRef, timelineLineSource);
      timelineLines = lineObjs;
      return;
    }

    const lines = await loadLines(cfg.linesUrl);
    buildFromPlainLines(fontRef, lines);
    prepareTimelineFromLineObjs(lineObjs);
    setTimelineTime(timelineState.currentMs || 0);
    renderTimelineFrame(performance.now());
  }

  cfgApplyBtn.addEventListener('click', async () => {
    const ok = applyCfgFromInputs();
    if (!ok) return;

    try {
      await loadFontFromSelection();
      setStatus('cfg + font applied.\nRebuilding scene…');
      await rebuildSceneFromCurrentSource();
      persistState();
      setStatus('cfg applied + rebuilt.\nReplaying…');
      replay();
    } catch (err) {
      setStatus('cfg rebuild failed:\n' + String(err));
    }
  });

  // -------------------------
  // Buttons
  // -------------------------
  btnLoad.addEventListener('click', async () => {
    if (!fontRef) { setStatus('Font not loaded yet.'); return; }

    setStatus('Loading transcription from Resolve…');
    const data = await loadTranscriptionFromResolve();

    if (data?.error) {
      setStatus(`Resolve error:\n${data.error}\n${data.instructions ? '\n' + data.instructions : ''}`);
      return;
    }

    transcriptionData = data;
    setCaptionSourceMode('lines');
    const wpl = Number(wplEl.value);
    const timedLines = transcriptionToTimedLines(data, wpl);

    if (!timedLines.length) {
      setStatus('Loaded transcription, but got 0 lines.\nAre subtitle items / word timings available?');
      return;
    }

    buildFromTimedLines(fontRef, timedLines);
    setStatus(`✓ Loaded Resolve transcript\nClip: ${data.clipName ?? '(unknown)'}\nWords: ${data.words?.length ?? 0}\nLines: ${timedLines.length}`);
    replay();
  });

  btnReplay.addEventListener('click', () => {
    setStatus('Replaying…');
    replay();
  });

  btnCreate.addEventListener('click', async () => {
    if (!transcriptionData?.words?.length) { setStatus('Load from Resolve first.'); return; }

    const wpl = Number(wplEl.value);
    setStatus('Creating captions in Resolve…');

    try {
      const res = await fetch('/api/create-animated-captions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ words: transcriptionData.words, wordsPerLine: wpl })
      });

      const out = await res.json();
      if (out?.error) { setStatus(`Create captions error:\n${out.error}`); return; }

      setStatus(`✓ Created captions in Resolve: ${out.created ?? 0}`);
    } catch (e) {
      setStatus(`Create captions failed:\n${String(e)}`);
    }
  });

  // -------------------------
  // Boot
  // -------------------------
  async function boot() {
    buildCfgEditorUI();
    populateFontPresets();
    populateTypographyProfiles();
      populateRevealStyles();
      populateThemes();
      populateEmphasisProfiles();
      keepPrevEl.checked = !!cfg.keepPreviousLinesVisible;
      wplValEl.textContent = String(wplEl.value);

      await hydrateState();
      syncWorkspaceInputs();
      await refreshProjects({ keepSelection: true });

      applyTextAlignSelection(cfg.textAlign, { silent: true });
      applyTheme(cfg.theme);
      setCaptionSourceMode(captionSourceState.mode);
      mediaUrlInput.value = captionSourceState.mediaUrl || '';
      applyOffsetEl.checked = !!captionSourceState.applyOffset;
      offsetMsInput.value = String(captionSourceState.offsetMs || 0);
      updateTimelineDisplay();

    const font = await loadFontFromSelection();

    // try Resolve first (silent)
    const data = await loadTranscriptionFromResolve();
    if (data && !data.error && Array.isArray(data.words) && data.words.length) {
      transcriptionData = data;
      const wpl = Number(wplEl.value);
      const timedLines = transcriptionToTimedLines(data, wpl);
      if (timedLines.length) {
        buildFromTimedLines(font, timedLines);
        setStatus(`Auto-loaded Resolve transcript\nWords: ${data.words.length}\nLines: ${timedLines.length}`);
        replay();
        return;
      }
    }

    // fallback to demo-lines.txt
    const lines = await loadLines(cfg.linesUrl);
    buildFromPlainLines(font, lines);

    camera.position.set(0, 0, cfg.cameraDistance);
    camera.lookAt(new THREE.Vector3(0,0,0));
    render();

    const rawLineCount = Math.max(lineImportStats?.rawLineCount || 0, lineImportStats?.segmentCount || 0);
    const segmentNote = (lineImportStats?.rawLineCount && lineImportStats.rawLineCount !== lineImportStats.segmentCount)
      ? ` (segments: ${lineImportStats.segmentCount})`
      : '';
    setStatus(`Loaded fallback demo-lines.txt\nLines: ${rawLineCount}${segmentNote}`);
    replay();
  }

  boot().catch((err) => setStatus('Boot error: ' + String(err)));

  // -------------------------
  // Resize
  // -------------------------
  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    render();
  });
</script>
</body>
</html>
